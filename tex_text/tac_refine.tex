\documentclass[journal,twoside,web]{IEEEtran}
\usepackage{cite}
\usepackage{algorithm}
\usepackage{algorithmicx,algpseudocode}
\usepackage{graphicx}      % include this line if your document contains figures
%\usepackage{natbib}        % required for bibliography
\usepackage{mathtools}
\usepackage{subfigure}
\usepackage{cases}
\usepackage{amsmath}
\usepackage{balance}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{comment}
\usepackage{color}
\usepackage{subfigmat}
\graphicspath{{./pic/}}
\newcommand{\qedwhite}{\hfill \ensuremath{\Box}}
\newtheorem{myrem}{Remark}
\newtheorem{dfn}{Definition}
\newtheorem{pbm}{Problem}
\newtheorem{exa}{Example}
\newcommand{\rdef}[1]{Definition\,\ref{#1}}
\newcommand{\req}[1]{\eqref{#1}} 
\newcommand{\rpbm}[1]{Problem\,\ref{#1}}
\newcommand{\rsec}[1]{Section\,\ref{#1}}
\newcommand{\rfig}[1]{Fig.\,\ref{#1}} 
\renewcommand{\Pr}{\widehat{Pr}}
\newcommand{\Count}{{\sf Count}}
\newcommand{\tick}{{\sf tick}}
\newcommand{\ttick}{{\textit tick}}
\newcommand{\AP}{{\textit AP}}
\newcommand{\ap}{{\textit ap}}

\newcommand{\Len}{{\sf L}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\W}{\mathcal{W}}
\newcommand{\U}[1]{\mathcal{U}_{[#1]}}
\newcommand{\F}[1]{\Diamond_{[#1]}}
\newcommand{\G}[1]{\Box_{[#1]}}

\newcommand{\red}[1]{\textcolor{red}{#1}}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{textcomp}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
%\markboth{\journalname, VOL. XX, NO. XX, XXXX 2017}
%{Author \MakeLowercase{\textit{et al.}}: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS (February 2017)}
%
%
%
\begin{document}
%
\title{Hierarchical Planning under Hard and Soft  Specifications Given by Ticked Linear Temporal Logic}
%
\author{Takuma Kinugawa, Toshimitsu Ushio, \IEEEmembership{Member, IEEE}
\thanks{The authors are with the Graduate School of Engineering Science, Osaka
University, Osaka, Japan (e-mail: kinugawa@hopf.sys.es.osaka-u.ac.jp,\ ushio@sys.es.osaka-u.ac.jp). }
\thanks{This work partially supported by JST ERATO Grant Number JPMJER1603 and JST CREST Grant Number JPMJCR2012.}
\thanks{The authors would like to thank Prof.\ K.\ Hashimoto(Osaka University) for his fruitful comments.}
}
\maketitle

\begin{abstract}
% Abstract of not more than 200 words.
%TDES実行列を求めるのは，実用上困難が多い．なぜなら，時間の制約を含んだ仕様を満たさないことがあるし，DESより大規模なシステムだと求めるのに時間がかかる．
%planner とコントローラーがあっていない
A hard problem for a real-time system is synthesis of a  planner or a controller that satisfies the given specification since a model of the system and the specification include temporal constraints.
%この論文では，それらに対するapproachesを提案します．
In this paper, to attack this problem, we propose two approaches to determine a plan for a real-time system modeled by a timed discrete event system (TDES), where a control specification is given by a ticked LTL$_f$ formula whose semantics is defined over a finite state sequence including a special event \textit{tick} that means the elapse of one time unit.
%一つ目は定量的な解を求める方法を提案します．
One approach is to relax the specification by partitioning the specification into \textit{hard constraints} and \textit{soft constraints}.
We give a preference, called \textit{weight}, to each soft constraint and find an execution of the TDES that satisfies all hard constraints and some soft constraints whose combination is prefer to any other one. 
%二つ目は階層型TDESの制御方法
Another approach is to represent a large-scale system by several subsystems, introducing a novel hierarchical model called hierarchical TDES.
Some states in the upper level TDES are refined by the lower level TDESs and time-scales of the upper level TDES and the lower level TDES can be different.
In the hierarchical TDES, rough plans are determined in the upper level TDESs, then detailed plans are determined in the lower level TDESs.
%
The effectiveness of each approach is illustrated through an example of a path planning problem of a mobile robot.
%
\end{abstract}

\begin{IEEEkeywords}
Linear temporal logic, path planning, timed discrete event system.
\end{IEEEkeywords}
%
\section{Introduction}
%
%
%
A discrete event system(DES) is useful for the design of a logical high-level controller in many engineering fields such as manufacturing systems, traffic systems, and robotics\cite{CL2008,CSX2018,SSS2013}.
%
For example, a planning problem is an important application of control of DESs \cite{ghallab2016automated}.  Both a considered system and its specification are modeled by a formal manner and the synthesis of a planner is formulated as a control problem.  
Ramadge and Wonham \cite{ramadge1987supervisory} considered a logical control problem called a supervisory control problem, where a specification is given by a formal language, and proposed an algorithm for synthesis of a supervisor.
%
%
However, in practice, it is difficult to determine formal languages that accurately describe desired behaviors of the DES.
So, a temporal logic(TL) formula has been used as a formal description of a control specification in the DES\cite{TW1986,JK2006,SU2018}.

%
Many different TLs have been proposed and their expressivenesses have been studied. 
Among them, the linear temporal logic(LTL) is often used because it can describe many properties such as safety, stability, and progress.
There are mainly two approaches to translate LTL formulas for use.
A basic approach is to translate an LTL formula into an automaton \cite{GV1999}. This approach is widely used for model checking \cite{BK2008}.
Another approach is to translate an LTL formula into its linear encodings \cite{BHJLS2006}. This approach is often used for bounded model checking using a satisfiability (SAT)-solver. 
Moreover, Soukry et al.\cite{S2016} provided an approach of motion planning with LTL specifications which are translated into linear encodings.
%
However, it is a drawback of LTL to need double-exponential time at worst to translate an LTL formula into an automaton.
The cyclic (loop) constraint is needed when we use linear encodings translated from an LTL formula\cite{sahin2019multirobot}. 
Kupferman and Vardi \cite{kupferman2001model} introduced the fragment of LTL, called safe/co-safe LTL. 
This fragment can be interpreted over a bad/good prefix of an infinite execution.
A syntactically co-safe LTL, that is a fragment of safe/co-safe LTL, is often used to give a specification for a planning problem \cite{cho2017cost,feyzabadi2016multi}.
%
However, every fragment of safe/co-safe LTL is restricted in its syntax, so that its expressiveness is poorer than one of LTL.  
To maintain rich expressiveness of LTL, LTL over finite execution, named LTL$_f$, was proposed and synthesis methods based on LTL$_f$ formulas have been studied recently\cite{Zhu2017,li2019sat}.
LTL$_f$ is defined over a finite execution with expressiveness of LTL.
Because of these good properties of LTL$_f$, LTL$_f$ formulas are recently used as specifications for planning problems\cite{camacho2019strong}.

On the other hand, when real-time systems are modeled, we also need to take temporal constraints for the systems into consideration.
For this reason, to represent temporal information of the real-time systems and real-time constraints in their DES models, Brandin et al.\cite{BW1994} formulated timed discrete event systems (TDESs) by a timed transition graph that is a transition graph with state transitions by the event \textit{tick}.
The occurrence of \textit{tick} represents that one unit time has elapsed.
In verification and control of TDESs, control specifications depend not only on logical constraints but also on the timing at which each event occurs. 
Koymans\cite{K1990} proposed TL, called metric TL(MTL),  for an infinite timed state sequence with a function that assigns the time stamp to each state.
The MTL formulas have been used as control specifications for TDESs.
Barbeau et al.\cite{BKD1998} dealt with a synthesis problem of controllers for TDESs with a control specification described by an MTL formula. 
Dhananjayan et al.\cite{DS2014} proposed an MTL specification interface that translates an MTL specification to a finite timed transition graph used in the synthesis of a timed supervisor.

%
In the previous works, the specifications are described by MTL formulas over infinite sequences of the TDESs. 
However, specifications for a planning problem are often given for a finite sequence\cite{camacho2019strong}. 
%
We provided a novel approach of a controller synthesis problem for TDESs, introducing a novel LTL called \textit{ticked LTL}$_f$\cite{KHU2020}.
As with the standard LTL$_f$\cite{Zhu2017}, the formula is interpreted over the finite execution.
In contrast to the standard LTL$_f$, the formula is given as an MTL, where temporal properties are described by counting the number of the event \textit{tick} in the execution of the TDES.
We presented a linear encoding scheme such that the problem can be translated into an integer linear programming (ILP) problem. 
Then, we solve a feasible solution of the ILP problem, so that we have a finite execution of the TDES satisfying the ticked LTL$_f$ specification.
However, there are the following two issues in \cite{KHU2020}.
\begin{itemize}
\setlength{\itemindent}{0.5cm}
\item[(P1)]
%Conflicts among specifications.
In some cases, we have no execution that satisfies a given specification though there may exist executions that satisfy a part of the given specification.
%
\item[(P2)]
%Difficulty to find an execution of a TDES modeling complex behavior
It is computationally difficult to find a finite execution in a long time horizon of a large-scale TDES satisfying many requirements. 
\end{itemize}
%
%
Related works for the above issues are summarized as follows.

%
For (P1), a specification is decomposed into a set of subspecifications and several approaches to the synthesis of a controller that satisfies as many subspecifications as possible have been proposed. 
Alur et al.\cite{AKW2008} presented an automaton-based algorithm.
For each subspecification with a priority and an automaton corresponding with a rank based on its priority is given. 
%
Then, the ``best'' selection of subspecifications are computed.
%
Dimitrova et al.\cite{DGT2018} proposed a method to formulate a weighted partial MaxSAT problem with quantitative specifications described by LTL formulas.
A weighted partial MaxSAT problem has mandatory constraints, called hard constraints, and optional constraints, called soft constraints, and there is a $weight$ for each soft constraint. 
This weight is used as a reward.
Then, the objective of a weighted partial MaxSAT problem is to find the assignment that satisfies all hard constraints and some soft constraints that maximize the sum of the weights.

%
For (P2), two approaches have been studied.
One approach is to model a complex system as the composition of simpler subsystems.
Queiroz and Cury\cite{QC2000} modeled a large-scale system by the composition of some smaller subsystems and a control specification is given for each subsystem.
%
Another approach is to leverage a model with a hierarchical structure.
%
Wong and Wonham\cite{WW1996a,WW1996b} introduced a hierarchical structure by abstracting the original systems using a bottom-up approach.
Gaudin and Marchand\cite{GAUDIN2004131} proposed the methods to model a system with a hierarchical structure using top-down approach and control this hierarchical model.
%
Ngo and Seow\cite{Ngo2018} proposed a control method for a hierarchical model with timing property.
%
Additionally, in \cite{8759973,7497833}, a multilevel DES composed of a finite number of levels was proposed. At each level, there are one or more groups of subsystems modeled by DESs. 
Each subsystem at each level except the lowest level can have one or more subsystems at the next-lower level.

%
%
In this paper, we propose methods to resolve both (P1) and (P2).
For (P1), we translate the ticked LTL$_f$ formula into its linear encodings based on \cite{DGT2018}. We partition a specification described by ticked LTL$_f$ formulas into a mandatory one corresponding to a hard constraint, and some optional ones corresponding to soft constraints.
%
Then, we assign a weight to each soft constraint corresponding to its preference and apply the MaxSAT to determines a set of satisfied soft constraints. 
For (P2), we introduce a hierarchical TDES where some states of the upper level TDES are refined by TDESs.
%
This structure is similar to \cite{GAUDIN2004131,8759973}.
However, we introduce different time-scales in the upper level and the lower level TDESs so that rough control actions in long time horizon are determined using the upper level TDES while detailed ones in short time horizon are determined using the lower level TDESs. 

%
%8
%
The rest of this paper is organized as follows.
In Section 2, we introduce the definition of TDES formulated by Brandin and Wonham\cite{BW1994}.
In Section 3, we review the definition of ticked LTL$_f$.
In Section 4, to deal with (P1), we partition a specification given by an LTL$_f$ formula into a hard constraint and several soft constraints with weights, and formulate a planning problem as a weighted partial MaxSAT problem.
We show an example where we can not find an execution of the TDES in \cite{KHU2020}.
In Section 5, we define a hierarchical TDES.
In Section 6, we present a method to give a specification for each higher level TDES and lower level TDES and to find its execution satisfying the given specification.
In Section 7, we apply the proposed method to a path planning problem of a mobile robot. 
Section 8 provides a summary of the paper and future research directions.
%
%
\section{Preliminary}
\subsection{Timed discrete event system}\label{tdes}
%
In this section, we review a timed discrete event system proposed by Brandin and Wonham\cite{BW1994}, where temporal information is modeled by a special event {\sl tick}. First, let us define an untimed discrete event system (DES) by a transition system.
%
\begin{dfn}[Untimed DES] \label{def:G_act}
An untimed DES is a tuple $G_{act}=(S_{act}, \Sigma_{act}, \delta_{act}, s_{init,act}, L_{act}, A_{act})$ where $S_{act}$ is a set of states, $\Sigma_{act}$ is a set of events, $\delta_{act} : S_{act} \times \Sigma_{act} \rightarrow S_{act}$ is a transition function, $s_{init,act}$ is the initial state, $AP_{act}$ is a set of atomic propositions, and $L_{act} : S_{act} \rightarrow 2^{AP_{act}}$ is a labeling function. \qedwhite
\end{dfn}

Next, we incorporate some \textit{timing} properties in $G_{act}$. 
We introduce $l_{\sigma} \in \mathbb{N}$, $u_{\sigma} \in  \mathbb{N} \cup \{\infty\}$ with  $l_{\sigma} \leq u_{\sigma}$ which are called the lower time and the upper time bound, respectively.
Additionally, for integers $m$ and $n$ with $m \leq n$, $[m,\ n]$ denotes a set of integers between $m$ and $n$, that is, $[m,\ n]=\{ m, m+1, \ldots , n\}$.
Then, we assume that each event $\sigma \in \Sigma_{act}$ is enabled during a specified timer interval $[ l_{\sigma},\ u_{\sigma}]$.
%
In particular, the event $\sigma$ is called a prospective ({\sl resp.} remote) event if $u_{\sigma} \in \mathbb{N}$ ({\sl resp.} $u_{\sigma} = \infty$). 
Let $\Sigma_{spe}$ and $\Sigma_{rem}$ $\subseteq \Sigma_{act}$ be the sets of prospective and remote events, respectively.  Note that $\Sigma_{spe} \cup \Sigma_{rem} = \Sigma_{act}$.
Then, we introduce the following timer interval $T_{\sigma}$ for each event $\sigma \in \Sigma_{act}$.
\begin{equation}
\label{T_sigma}
T_{\sigma}= \left\{
\begin{array}{ll}  
\ [ 0,\ u_{\sigma} ]  & \mbox{if } \sigma \in \Sigma_{spe}, \\
\ [ 0,\ l_{\sigma} ] & \mbox{if } \sigma \in \Sigma_{rem}. \\
\end{array} \right.
\end{equation}	 
%
\red{We denote a tuple of a DES $G_{act}$, its unit time $\tick$, and the corresponding timer intervals $T_{\sigma}$ ($\sigma\in \Sigma_{act}$) as $\overline{G}\coloneqq (G_{act},{\tick},\{T_{\sigma} |~\sigma\in \Sigma_{act} \})$.}
We introduce a special event \textit{tick}, which represents the global clock and will be utilized as an additional event to $\Sigma_{act}$. 
Based on the above definition, a timed DES corresponding to  is defined as follows: 

\begin{dfn}[Timed DES]\label{def:G}
A timed DES (TDES) corresponding to $G_{act}$ is a tuple $G=(S, \Sigma, \delta, s_0,AP, L)$ where $S = S_{act} \times \prod_{\sigma\in \Sigma_{act}} T_{\sigma}$ is a set of states, $\Sigma= \Sigma_{act} \bigcup \{\textit{tick}\}$ is a set of events, $s_0 \in S$ is the initial state where $s_0 = (s_{init,act}, \{ t_{\sigma,0} | \sigma \in \Sigma_{act} \})$ and $t_{\sigma,0}$ is given by
					\begin{equation}
						t_{\sigma, 0} \coloneqq \left\{
						\begin{array}{ll}  
							\ u_{\sigma}  & \mbox{if } {\sigma} \in \Sigma_{spe}, \\
							\ l_{\sigma} & \mbox{if } {\sigma } \in \Sigma_{rem}, \\
						\end{array} \right.
					\end{equation}	
$AP = AP_{act} $ is a set of  atomic propositions and $L  : S \rightarrow 2^{AP} $ is a labeling function, where $L(s)=L_{act}(a)$ \red{for all} $s = (a, \{ t_\sigma | \sigma \in \Sigma_{act} \}) \in S$. \qedwhite \end{dfn}
%
The concrete definition of the transition function $\delta:~S\times \Sigma \to S$ is omitted in this paper and the reader is referred to \cite{BW1994} for details.
%
%
%
%
A \textit{finite execution $\pi$ of} $G$ is a finite sequence of alternating states and events
\begin{align}\label{execution}
\pi = s(0)e(1)s(1)\ldots e(\Len) s(\Len), 
\end{align}
where $\Len \in \mathbb{N}_{> 0}$, 
$s(k) \in S$ with $s(0) = s_0$, $\forall k\in[0,\ \Len]$, $e(k') \in \Sigma$, $\forall k' \in [1,\ \Len]$ and \red{$s(l)= \delta(s({l-1}), e({l}))$}, $\forall l\in [1,\ \Len]$. 
Here, $\Len$ is called the \textit{length} of $\pi$.
Moreover, the corresponding sequence of states 
\begin{align}
s(0) s(1) \ldots, s(\Len) \notag
\end{align}
is called a \textit{trajectory} of $G$. 
For given \req{execution} and $k\in[0,\ \Len]$, let $\pi(k) = s(k)$, and 
\begin{align}
\pi(k...) = s(k) e({k+1}) s({k+1}) \ldots e({\Len}) s({\Len}), \notag 
\end{align}
i.e., $\pi(k...)$ denotes the $k$-th suffix of $\pi$. Moreover, for given $k, j\in[0,\ \Len]$ with $k\leq j$, let $\pi(k...j)$ be the partial suffix given by 
\begin{align}
\pi(k...j) = s(k) e({k+1}) s({k+1}) \ldots e({j}) s({j}). \notag 
\end{align}
Moreover, for given \req{execution} and $k, j\in [0,\ \Len]$ with $k \leq j \leq \Len$, let $count_\pi(k,j)$ denote the number of the event \textit{tick} included in $\pi(k...j)$.
Note that it takes $count_{\pi}(0, {\Len})+1$ unit times to complete the execution $\pi$ and we call this time \textit{the time for $\pi$}.
%
For example, if $\pi=a,\textit{tick},a,\sigma,b,\textit{tick},a$ with $S=\{a,b\}$ and $\Sigma = \{\sigma\}\cup \{\textit{tick}\}$, we have $count_\pi(0,3) = 2$, $count_\pi (1, 3) = 1$ since $\pi(0...3) = a,\textit{tick},a,\sigma,b,\textit{tick},a$ and $\pi(1...3) = a,\sigma,b,\textit{tick},a$. Note that we have $count_\pi(k, k)=0$, $\forall k \in [ 0, \ \Len ]$, since $\pi(k...k) = s(k)$ and so no events occur in $\pi(k...k)$.
%
%

To focus on states in $S_{act}$, a function $\Pr: S \cup \Sigma \to S_{act} \cup \Sigma $ for $G$ is defined as follows.
\label{def:Pr}
\[
\Pr (x )=\left\{
\begin{array}{ll}
s_{act} & \mbox{if }x =(s_{act}, (t_{\sigma})) \in S,  \\ 
x  & \mbox{if } x \in \Sigma , 
\end{array} \right.
\]
where $x  \in S  \cup \Sigma $. 
$\Pr : S \cup \Sigma \to S_{act} \cup \Sigma$ is extended to $\Pr : (S  \cup \Sigma )^* \to  (S_{act} \cup \Sigma )^*$ in the usual way.
%
%
\subsection{ticked linear temporal logic}
We now introduce a fragment of linear temporal logic called ticked LTL$_f$ over a TDES\cite{KHU2020}.
As will be seen below, this formula is interpreted over a finite execution \req{execution}, and provides an extension of the LTL$_f$ formulas\cite{Zhu2017} in the sense that we incorporate some timing properties via the event ${\textit{tick}}$\footnote{By the similar way, we can define ticked LTL, but we consider ticked LTL$_{f}$ in this paper since we deal with planning over a finite length.}.
First, we define its syntax as follows.

\begin{dfn}[Syntax of ticked LTL$_f$]\label{dfn:syntax}
A ticked LTL$_f$ formula over a finite sequence of sets of atomic propositions is recursively defined according to the following grammar: 
\begin{align}
\phi \coloneqq True \ |\ ap\ |\ \lnot \phi\ |\ \phi_1\land \phi_2\ |\ \phi_1U_{[m,n]} \phi_2 ,\notag
\end{align}
where $ap \in AP$, $m$ and $n$ are nonnegative integers with $m\leq n$. \qedwhite
\end{dfn}
%
Additionally, we use the following boolean operators.
\begin{align}
\phi_1 \lor \phi_2 &\coloneqq \lnot(\lnot \phi_1 \land \lnot \phi_2), \notag\\ 
\phi_1 \rightarrow \phi_2 & \coloneqq \lnot \phi_1 \lor \phi_2, \notag\\ 
\phi_1 \leftrightarrow \phi_2 &\coloneqq (\phi_1 \rightarrow \phi_2)\land(\phi_2 \rightarrow \phi_1). \notag
\end{align} 
Moreover, other temporal operators, such as $\Diamond_{[m,n]}$ (future) and $\Box_{[m,n]}$ (globally) are defined by
\begin{align}\label{futureglobal}
\Diamond_{[m,n]} \phi \coloneqq True U_{[m,n]} \phi, \ \Box_{[m,n]} \phi \coloneqq \lnot \Diamond_{[m,n]} \lnot \phi. 
\end{align}
%
Its semantics is defined over a finite execution in \req{execution} and is formally given as follows. 
\begin{dfn}[Semantics of ticked LTL$_f$]
Given a finite execution $\pi = s(0) e(1)$$s(1) \ldots e(\Len) s(\Len)$, the satisfaction of the ticked LTL$_f$ formula $\phi$ for the $k$-th suffix of $\pi$ $(k\in [0,\ \Len])$, denoted as $\pi (k...) \models \phi$, is defined recursively as follows.
\begin{itemize}
\item 	$\pi(k...) \models True$,
\item 	$\pi(k...) \models ap$ if and only if $ap \in L(\pi(k))$,
\item 	$\pi(k...) \models \lnot \phi$ if and only if $\pi(k...) \not\models \phi$,
\item 	$\pi(k...) \models \phi_1\land \phi_2$ if and only if $\pi(k...) \models \phi_1 \land \pi(k...)\models \phi_2$,
\item 	$\pi(k...) \models \phi_1U_{[m,n]} \phi_2$ if and only if there exists $j \in [k ,\ \Len]$ such that $m \leq count_\pi(k, j) \leq n$, $\pi(j...) \models \phi_2$ and $\pi(i...) \models \phi_1$, $\forall i \in [k,j-1]$. \qedwhite
	\end{itemize}
	\end{dfn}

Intuitively, the formula $\phi_1 U_{[m,n]}  \phi_2$ indicates that $\phi_1$ holds true until $\phi_2$ holds true during the interval such that the number of ticked events is between $m$ and $n$. 
Note that we do not include the operator $\bigcirc$ (next) in the \red{syntax since, by the meaning of tick,} $F_{[1,1]}$ can be used as $\bigcirc$. 
We denote by $\pi \models \phi$ if and only if $\pi (0...) \models \phi$.

\begin{exa}
Consider the following finite execution.
\begin{align}
\pi=a,\textit{tick},a,\sigma,b,\textit{tick},a \notag
\end{align}
and a ticked LTL$_f$ formula $\phi=ap_1 U_{[1,3]} ap_2$ with $AP=\{ap_1,ap_2\}$, $S=\{a,b\}$, $\Sigma=\{\sigma\}\cup\{\textit{tick}\}$ and $L(a)=\{ap_1\},\ L(b)=\{ap_2\}$. Then, $\pi(0...) (= a,\textit{tick},a,\sigma,b,\textit{tick},a)$ satisfies $\phi$, since $a$ holds true until $b$ holds true while the number of \textit{tick} counted from $\pi(0)$ is $1$, i.e., $count_{\pi}(0, 2) = 1 \in[ 1,\ 3]$. However, $\pi (1...) (= a,\sigma,b,\textit{tick},a)$ does \textit{not} satisfy $\phi$, since $b$ holds true while the number of \textit{tick} counted from $\pi(1)$ is $0$, i.e., $count_{\pi}(1, 2) = 0 \notin [1, 3]$. \qedwhite 
\end{exa}




%\section{Planning under ticked LTL$_f$ constraints}\label{sec4}
%
%In general, for a planning problem with a modular specification consisting of several subspecifications, no execution satisfying all subspecifications may exist though an execution satisfying some of them exists. In such a case, one approach to relax the specification is to partition the subspecifications into a mandatory one called a hard constraint and several optional ones called soft constraints, where the former is the indispensable requirement and the latter describes a requirement preferable to be satisfied.  Then, we find an execution, called a plan, satisfying the hard constraint and some of the soft ones such that the set of the satisfied soft ones is the most preferable for a designer. We formulate an optimal planning problem with a hard constraint and a set of soft constraints described by  ticked LTL$_f$ formulas for a TDES $G$ as an integer linear programming (ILP) problem.

%In this section, first, we review the linear encoding of both executions of $G$ and the constraints.  Then, we provide the formulation and show an illustrative example.

\subsection{Encoding of constraints}\label{encode}
%
We review a method that encodes a finite trajectory of the TDES $G=(S, \Sigma, \delta, s_{init}, AP, L)$, where $s_{init} \in S= \{s_1, s_2 \ldots, s_{N} \}$, the counting function $count_\pi$, and the ticked LTL$_f$ formula $\phi$ using inequality and equality constraints.
This method is an extension of the method proposed by \cite{BHJLS2006}.  See \cite{KHU2020} for its detail.
%
\subsubsection{TDES}
Let $\pi_{G}=s(0)e(1)s(1) \ldots e(\Len)s(\Len)$ be an execution of the TDES $G$, where $\Len$ is the length of $\pi$ and $s(0)=s_{init}$.
We introduce $\Len+1$ binary vectors $w_G (k)=[w_{G,1} (k), w_{G,2} (k) , \ldots , w_{G,N_S} (k) ]^{\mathsf{T}} \in \{0, 1\}^{N_S}$ with $N_S=|S|$ for $k\in [0,\ \Len]$ to represent the $k$-th state $s(k)$ of $\pi$ as follows.
\[
w_{G,i}(k)=\left\{ \begin{array}{ll}
1 & \mbox{if } s(k)=s_i, \\
0 & \mbox{otherwise.}
\end{array} \right.
\]
Additionally, we introduce a binary vector $w_{G,s_0}=[w_{G,s_0,1} (k), w_{G,s_0,2} (k) , \ldots , w_{G,s_0,N_S} (k) ]\in \{0, 1\}^{N_S}$ to represent the initial state of $G$ as follows.
\[
w_{G,s_0,i}=\left\{ \begin{array}{ll}
1 & \mbox{if } s_0=s_i, \\
0 & \mbox{otherwise.}
\end{array} \right.
\]

Denoted by $A_G \in \{0, 1\}^{N_S \times N_S}$ is the \textit{transition matrix} of  $G$, where the $(i,j)$-th element $A_{G,i,j}$ of $A_G$ is defined by
\[
A_{G,i,j}=\left\{ \begin{array}{ll}
1 & \mbox{ if } \exists \sigma \in \Sigma.\ s_j=\delta(s_i, \sigma), \\
0 & \mbox{otherwise.}
\end{array} \right.
\]
 

Then, we have the following encoding.
\begin{equation}\label{w}
w_G(k+1) \leq A_{G}^{\mathsf{T}} w_G(k), \ {1}^\mathsf{T} _{N_S} w_G(k) =1, 
\end{equation}
where ${1}_{N_S}$ is the $N_S$-dimensional vector whose all elements are 1.
%
%

We introduce the following variables $z_{G,e}(k)$, $k\in[1,\ \Len]$ which indicates if $e(k)$ is the event \textit{tick} or not.
\[
z_{G,e}=\left\{ \begin{array}{ll}
1 & \mbox{ if } e(k)=tick, \\
0 & \mbox{otherwise.}
\end{array} \right. .
\]
We introduce two binary vectors $\alpha=[\alpha_1, \alpha_2,\ldots , \alpha_{N_S}]^{\mathsf{T}} \in \{0, 1\}^{{N_S}}$ and  $\beta=[\beta_1, \beta_2,\ldots , \beta_{N_S}]^{\mathsf{T}} \in \{0, 1\}^{{N_S}}$ defined by

\begin{eqnarray*}
\alpha_{i}&=&\left\{ \begin{array}{ll}
1 & \mbox{ if } \delta(s_i, tick)!, \\
0 & \mbox{otherwise,}
\end{array} \right.\\
\beta_{i}&=&\left\{ \begin{array}{ll}
1 & \mbox{ if } \exists s_j. s_i=\delta(s_j,tick)!, \\
0 & \mbox{otherwise.}
\end{array} \right.
\end{eqnarray*}
Then, $z_{G,e}(k)=1$ if and only if
\begin{align}%\label{count_constraint}
\alpha^\mathsf{T} w_G (k-1) = 1 \wedge \beta^\mathsf{T} w_G (k) =1. \notag 
\end{align}
Thus, $z_{G,e}(k)=1$ if and only if the following equations hold.
\begin{align}
z_{G,e} (k) &\leq \alpha^\mathsf{T} w_G (k-1),\label{zek1} \\
z_{G,e} (k) &\leq \beta^\mathsf{T} w_G (k), \label{zek2}  \\
z_{G,e} (k) & \geq -1 + \alpha^\mathsf{T} w_G (k-1) + \beta^\mathsf{T} w (k).\label{zek3}
\end{align}

Then, denoted by $SYS(G)$ is a set of constraints (\ref{w})-(\ref{zek3}) for the TDES $G$.


\subsubsection{Counting function}
For each $k, j \in [0,\ \Len]$ with $k\leq j$, let $c_{\pi_G} (k, j) \in \mathbb{N}$ be an integer variable that represents how many times the event \textit{tick} occurs in $\pi_G(k...j)$, i.e., $c_{\pi_G}(k,j) = m$ if and only if $count_{\pi_G}(k,j) = m$. 
Using $z_{G,e} (k)\, (k \in [0,\ \Len])$, we have
\begin{equation}\label{ckj}
c_{\pi_G} (k, j) = \left\{ \begin{array}{ll}
\displaystyle{\sum^j _{i = k+1} z_{G,e} (i)} & \mbox{if } k<j , \\
0 & \mbox{if } k=j.
\end{array} \right. 
\end{equation}



%
\subsubsection{Ticked LTL$_f$ formula}\label{encLTL}
%   
We introduce $\Len+1$ binary variables $z_{\varphi}(k) \in \{0,1\}$ for $k \in [0,\ \Len]$ such that $z_{\varphi}(k)=1$ if and only if $\pi_G (k, \Len)$ satisfies $\varphi$.
Then, the linear encoding corresponding to the satisfaction of  the ticked LTL$_f$ formula $\varphi$ is recursively given as follows.
%
%

\textit{Atomic proposition:} Let $\varphi = ap \in AP$ and $v \in \{0, 1\}^{N_S}$ be a binary vector such that $v_i = 1$ (the $i$-th component of $v$ is $1$) if and only if $ap \in L(s_i)$. Then, the satisfaction of the formula $\varphi$ is encoded as follows: 
\begin{align}
v^\mathsf{T} {w_G}(k) &\geq z_\varphi (k),\notag\\
v^\mathsf{T} {w_G}(k) &< z_\varphi (k)+1. \notag
\end{align}

\textit{Negation:} Let $\varphi = \neg \varphi'$. Then, the satisfaction of $\varphi$ is encoded as 
\begin{align}\notag
z_\varphi (k) = 1 - z_{\varphi'} (k). 
\end{align}

\textit{Conjunction:} Let $\varphi = \bigwedge^{\Len} _{\ell=1} \varphi_\ell$. Then, 
\begin{align}
\label{translate_con}
z_\varphi (k) &\leq z_{\varphi_\ell} (k),\ \forall \ell \in [1,\ \Len], \notag \\ 
z_\varphi (k) & \geq 1-\Len + \sum_{\ell=1}^{\Len} z_{\varphi_\ell} (k). \notag
\end{align}

\textit{Disjunction:} Let $\varphi = \bigvee^{\Len} _{\ell=1} \varphi_\ell$. 
Then, 
\begin{align}
z_\varphi (k) &\geq z_{\varphi_\ell} (k),\ \forall \ell \in [1,\ \Len], \notag \\ 
z_\varphi (k) & \leq \sum_{\ell=1}^{\Len} z_{\varphi_\ell} (k). \notag
\end{align}
%%%
With a slight abuse of notation, Boolean operators are used for binary variables. For example, when we consider $\varphi = \bigwedge^\Len _{\ell=1} \varphi_\ell$, we write $z_\varphi = \bigwedge^{\Len} _{\ell=1} z_{\varphi_\ell}$. % instead of \req{translate_con}. 
Then, we describe the translation of the temporal operator \textit{until} with this notation.
%%%

\textit{Until:} 
Let $\varphi = \varphi_1 U_{[m,n]} \varphi_2$. We introduce binary variables $\underline{z}_m (k, j), \overline{z}_n (k, j) \in \{0, 1\}$, for $k, j \in [0,\ \Len]$ with $k\leq j$,
such that $\underline{z}_m (k,j) = 1$ ({\sl resp.} $\overline{z}_n (k, j) = 1$) if and only if $m \leq c_{\pi_G} (k, j)$ ({\sl resp.} $c_{G_e}(k,j) \leq n$). Then, we have 
\begin{eqnarray}
m - M_c &\leq c_{\pi_G} (k, j) - M_c \underline{z}_m(k,j) &\leq m - \epsilon, \notag\\ 
{n} + \epsilon  &\leq  c_{\pi_G} (k, j) + M_c \overline{z}_n(k,j) &\leq {n}+M_c, \notag
\end{eqnarray}
where $M_c$ is a sufficiently large number satisfying $M_c >n$ and $\epsilon$ is a sufficiently small number satisfying $\epsilon<1$.
Then, the satisfaction of $\varphi$ is encoded as 
\begin{align}%\label{until1}
z_\varphi (k) = \bigvee^{\Len} _{j=k} z_\varphi (k, j),
\end{align}
where 
\begin{align}%\label{until2}
z_\varphi (k, j) = \overline{z}_n (k,j) \wedge  \underline{z}_m (k,j) \wedge z_{\varphi_2} (j) \wedge \left(\bigwedge^{j-1} _{\ell=k} z_{\varphi_1} (\ell) \right).  \notag 
\end{align}

The encodings for $\Diamond_{[m,n]}$ and $\Box_{[m,n]}$are similarly done from  \req{futureglobal} and are thus omitted. 
%

Denoted by $LTL(\varphi)$ is the set of constraints obtained by the above encoding for the ticked LTL$_f$ formula $\varphi$. 



%\begin{comment}


\begin{comment}


%
\red{
\subsection{Problem formulation}\label{sec:pbm}
}
%


When we introduce the soft constraints to a planning problem, we have two performance indexes $J_{time}$ and $J_{soft}$ for a plan: $J_{time}$ indicates how fast the plan is completed and $J_{soft}$ indicates how large the sum of the preferences of the satisfied soft constraints is.
Then, A preferable plan minimizes $J_{time}$ and maximizes $J_{soft}$ simultaneously, which causes a trade-off between the indexes. To represent the trade-off, we introduce the following objective function $J_{\kappa}$ with $0 \leq \kappa \leq 1$.
\begin{equation}
J_{\kappa}=-\kappa J_{time} + (1-\kappa) J_{soft}.
\end{equation}
The parameter $\kappa$ represents which index is more important.
Then, roughly speaking, we consider the following optimal planning problem:
Given a TDES $G$ with the initial state $s_0$, the length $\Len>0$ of the plan,  a hard constraint described by a ticked LTL$_f$ formula $\phi$, $N$ soft constraints described by the ticked LTL$_f$ formula $\psi_{i}$ and the weight $w_i$ for $i\in[1,\ N]$, and the objective function $J_\kappa$,
find a plan $\pi$ with the length $\Len$ for $G$ that maximizes the objective function $J_{\kappa}$ subject to $\pi \models \phi$.

In the following, we consider the following objective function based on the binary variables used in the encoding of a trajectory of $G$ and the ticked LTL$_f$ formula $\psi_{i}$.
\begin{align}\label{j1}
J_\kappa= 
-\kappa\sum_{k=1}^{\Len}z_e(k) + (1-\kappa)\sum_{i=1}^{N} w_{i}\cdot z_{\psi_{i}(0)}, 
\end{align}
where $z_e(k)=1$ means that the $k$-th event of the trajectory is $tick$ and $z_{\psi_{i}(0)}=1$ means that the plan satisfies the soft constraint $\psi_{i}$.
Note that $J_{time}=\sum_{k=1}^{\Len}z_e(k)$ indicates the number of the event $tick$ in the trajectory corresponding to the plan and
$J_{soft}=\sum_{i=1}^{N} w_{i}\cdot z_{\psi_{i}(0)}$ is the sum of the preferences of the soft constraints satisfied by the plan.
Then, we formulate the optimal planning problem as follows.


%
\begin{pbm}\label{pbm2}
Find optimal binary vectors $\red{w_G}(k) \in \{0, 1 \}^N$ \red{$(k\in[0,~ \Len])$} for the following ILP problem {\bf ILP\ref{pbm2}}, which correspond to an optimal plan.
\begin{eqnarray}
\mbox{\bf ILP\ref{pbm2}}: &\mbox{maximize }&J_\kappa \notag \\
&\mbox{subject to }&SYS(G) \notag \\
&& LTL(\phi),\notag \\
&& LTL(\psi_i) \  {\rm{for\ each\ }}  i \in [1,\ N], \notag\\
&& w_G(0)=w_{s_0}, \notag \\
&&z_{\phi} (0) = 1, \notag
\end{eqnarray}
where $w_{s_0} \in \{0, 1 \}^N$ is the binary vector corresponding to the initial state $s_0$.
\qedwhite
\end{pbm}
%


The procedures to solve \rpbm{pbm2} is described in Algorithm 1 in detail. 
%

%
%
\subsection{Example}\label{sec:sim1}
%
In this section, we demonstrate the effectiveness of the proposed approach by a simulation of a path planning problem for a mobile robot.
\red{The simulation was run by a machine with AMD Ryzen9 5950X and 128GB memory, and the solver Gurobi\footnote{https://www.gurobi.com/} was used to compute an optimal solution of this ILP problem.}
%
\subsubsection{Setting of TDES}
\label{settingDES}
%
%
\begin{figure}
\centering 
\includegraphics[width=8cm]{1-c4-crop.pdf}
\caption{The untimed DES $G_{act}$ considered in \rsec{sec:sim1}.}
\label{sim1}
\end{figure}
%
We consider the system whose logical behavior is modeled by an untimed DES $G_{act}$ shown in \rfig{sim1}.
In the figure, each node represents the state of the system, and each edge represents the transition between them. 
The symbol $(e,l_e,u_e)$ near each edge represents the event  $e\in\Sigma_{act}$ associated with the edge, the lower time of $e$, and the upper time of $e$, respectively. The element in parentheses next to $s_i$ represents atomic propositions assigned to $s_i$ for $i\in[0,~5]$.
The initial state is $s_0$.
%
Based on the above definitions, the corresponding timed DES $G$ is constructed according to \rdef{def:G}. 
%
\subsubsection{Simulation result}
%
We consider the following hard constraint, and soft constraints and their weight.
\begin{align}
\phi=&\F{0,\Len}p_{fin},\notag \\
\Psi 
=&\{
(\psi_1=\G{0,\Len}(\lnot p_s),3),~
(\psi_2=\F{0,\Len}p_3,1),\notag \\
&~~(\psi_3=\F{0,\Len}p_4,1),~
(\psi=((\lnot p_4) \U{0,\Len} p_3,2)
\}.\notag
\end{align}
%
We use Gurobi to compute an optimal execution that optimizing the objective function $J_\kappa$. 
Let $\Len=20$. We compute optimal executions $\pi^1$, $\pi^2$, and $\pi^3$ with $\kappa=0.01,0.5,1$, respectively, such that $\Pr(\pi^1)$, $\Pr(\pi^2)$, and $\Pr(\pi^3)$ are given by
\begin{align}
\Pr(\pi^1)=&
s_0,\ttick,s_0,\ttick,s_0,e_{03},s_3,\ttick,s_3,\ttick,\notag\\
&s_3,e_{34},s_4,\ttick,s_4,e_{40},s_0,e_{01},s_1,\notag\\
&\ttick,s_1,e_{12},s_2,\ttick,s_2,e_{25},s_5,\ldots,s_5\notag\\
\Pr(\pi^2)=&
s_0,\ttick,s_0,\ttick,s_0,e_{03},s_3,\ttick,\notag\\
&s_3,\ttick,s_3,e_{35},s_5,\ldots,s_5\notag \\
\Pr(\pi^3)=&s_0,e_{01},s_1,\ttick,s_1,e_{12},s_2,\ttick,s_2,e_{25},s_5,\ldots,s_5\notag
\end{align}
%
The time for $\pi^1$, $\pi^2$, and $\pi^3$ are 7, 4, and 2 [\tick], respectively.
The sum of weight of soft constraints satisfied by $\pi^1$, $\pi^2$, and $\pi^3$ are 4, 3, and 0.
The results of executions are shown that the combination of satisfied soft constraints is changed when the value of $\kappa$ is changed while satisfying the hard constraint.
%
%



\end{comment}


%
%
%
\begin{comment}
%
\section{Planning under ticked LTL$_f$ constraints}\label{sec4}
%
We consider a planning problem for a system modeled by a TDES $G$.
A specification for this plan is given by a ticked LTL$_f$ formula introduced in the previous section. 
In general, however, no execution satisfying the specification may exist though we find an execution that partially satisfies it. 
One approach to relax the specification is to partition the formula into a mandatory subformula called a hard constraint and several optional subformulas called soft constraints, where the former is the indispensable requirement and the latter describes a requirement preferable to be satisfied.  
Some specifications for the plan are represented as soft constraints.  
We assign to each soft constraint a weight that indicates the preference for its satisfaction and propose a method for finding a solution.

%
\red{
\subsection{Problem formulation}\label{sec:pbm}
}
%
We assume that there are one hard constraint $\phi$ and $N$ soft constraints $\psi_1,...,\psi_N$. 
When we introduce soft constraints to a planning problem, we consider the following points.
\begin{itemize}
\item
There are combinations of satisfaction of soft constraints.
\item
There is a trade-off between the shortness of the time for the result of(resulting) execution and the sum of weights of the soft constraints satisfied by the execution.
\end{itemize}

For the first point, we consider the case where a preference on the satisfiability of soft constraints exists.
To explain the preference of the satisfactions of the soft constraints, we introduce a positive constant called $weight$ for each soft constraint.
For each soft constraint $\psi_n (n \in [1,N])$, its weight is denoted by $weight_n$. The larger sum of weights of satisfied soft constraints is preferred.
We denote a set of pairs of a soft constraint and its weight by $\Psi=\{(\psi_n,w_n)|~n\in[1,~N]\}$.

For the second point, 
the combination of satisfaction of soft constraints is changed if we change the ratio of the importance of the time for the result of execution to that(=the importance) of the sum of weights of the satisfied soft constraints.
For example, if the time for the result of execution is important, many soft constraints may not be satisfied. 
On the other hand, if we focus on the sum of weights of the satisfied soft constraints, many soft constraints can be satisfied, while it will take more time.
Let $\kappa(0\leq\kappa\leq1)$ be the ratio of the importance of the time for the result of execution to the sum of weights of the satisfied soft constraints.
Then, we set an objective function 
%$J_\kappa(z_e(0),\ldots z_e(\Len),z_{\psi_1},\ldots,z_{\psi_N})$
$J_\kappa$
to represent these two points and we formulate the problem where the specification is given by a hard constraint and several soft constraints to find an optimal execution of the TDES as follows.
%
\begin{pbm}\label{pbm2}
Given a TDES $G$, a hard constraint given by a ticked LTL$_f$ formula $\phi$, $N$ soft constraints given by ticked LTL$_f$ formulas $\psi_{n}$ and their weights $w_n$ for $n\in[1,\ N]$, the length $\Len>0$, and the objective function $J_\kappa$,
find a finite execution $\pi$ of $G$ such that
\begin{eqnarray}
&\mbox{max: }&J_\kappa \notag \\
&\mbox{subject to: }&\pi \models \phi\mbox{, and transition lows of }G\notag
\end{eqnarray}
\qedwhite
\end{pbm}
%
If there is no solution of the ILP problem, i.e., we can not find an execution of $G$ under constraints $\phi$, we denote $\pi=\bot$.
%
To solve \rpbm{pbm2}, we use the following linear encoding schema presented in \cite{KHU2020}.
%
\subsection{Encoding of constraints}\label{encode}
%
We translate a finite trajectory of the TDES $G$, the counting function $count_\pi$, and the ticked LTL$_f$ formula $\phi$ into a set of inequality and equality constraints that can be solved by an integer linear programming (ILP) problem.
The method to translate the ticked LTL$_f$ formula is proposed by extending the method proposed by \cite{BHJLS2006}. Details for the encodings are described below. 
%
\subsubsection{Trajectory of $G$}
To encode the trajectory of $G$, we denote by $A \in \{0, 1\}^{N \times N}$ with $N=|S|$ the \textit{adjacency matrix} of the graph in accordance with $G$, i.e., letting $S = \{s_1, ..., s_{N}\}$, we have $A_{i,{j_i}} = 1$ (the $(i,{j_i})$-component of $A$ is $1$) if and only if there exists $\sigma \in \Sigma$ such that $s_j \in \delta(s_i, \sigma)$, and $0$ otherwise. Moreover, we introduce $\Len+1$ binary vectors $w (k) \in \{0, 1\}^{N}$, $k\in [0,\ \Len]$ to represent the state of $G$ at $k$, where, for each $k \in [0,\ \Len]$, the vector $w(k)$ includes only one non-zero component. That is, if $\pi$ is given by \req{execution}, we have $w_i (k) = 1$ (the $i$-th component of $w(k)$ is $1$) if and only if $s(k) = s_i$, and $0$ otherwise. The trajectory of the states can be then encoded as follows: 
\begin{equation}\label{w}
w(k+1) \leq A^\mathsf{T} w(k), \ {1}^\mathsf{T} _N w(k) =1, 
\end{equation}
where ${1}_N$ is the $N$-dimensional vector whose all elements are 1.
%
%
\subsubsection{Counting function}
Let $c (k, j) \in \mathbb{N}$ for $k, j \in [0,\ \Len]$ with $k\leq j$ be integer variables that represent the number of \textit{tick} events in
%
%
$\pi(k...j)$, i.e., $c(k,j) = m$ if and only if $count_\pi(k,j) = m$. The $c(k,j)$ represents an ILP problem constraint as follows. First, we introduce $\Len$ binary variables $z_e (k) \in \{0, 1\}$, for $k\in[1,\ \Len]$ in order to represent the occurrence of \textit{tick} in the sequence of events, i.e., if $\pi$ is given by \req{execution}, we have $z_e(k) = 1$ if and only if $e(k) = \textit{tick}$. Using $z_e (k)$, $k \in [0,\ \Len]$, $c(k, j)$ is then given by
\begin{align}\label{ckj}
c (k, j) =   \sum^j _{i = k+1} z_e (i),
\end{align}
for $k, j \in [0,\ \Len]$ with $k < j$, and $c (k, k) = 0$, $\forall k\in[0,\  \Len]$. 
The variables $z_e(k)$, $k\in[1,\ \Len]$ encodes whether $e(k)$ is the event \textit{tick} or not. First, let $\alpha \in \{0, 1\}^{N}$ be a binary vector such that $\alpha_i = 1$ (the $i$-th component of $\alpha$ is $1$) if and only if $\delta (s_i, \textit{tick}) !$ (i.e., the event \textit{tick} occurs at $s_i$). Moreover, let $\beta \in \{0, 1\}^{N}$ be a binary vector such that $\beta_i = 1$ (the $i$-th element of $\beta$ is $1$) if and only if there exists $s_{j} \in S$ such that $s_i = \delta (s_{j}, \textit{tick})$ (i.e., there exists a state that can transit to $s_i$ by the occurrence of the event \textit{tick}).

Then, $z_e(k)=1$ if and only if
\begin{align}%\label{count_constraint}
\alpha^\mathsf{T} w (k-1) = 1 \wedge \beta^\mathsf{T} w (k) =1. \notag 
\end{align}
Thus, $z_e(k)=1$ if and only if the following equations hold.
\begin{align}
z_e (k) &\leq \alpha^\mathsf{T} w (k-1),\label{zek1} \\
z_e (k) &\leq \beta^\mathsf{T} w (k), \label{zek2}  \\
z_e (k) & \geq -1 + \alpha^\mathsf{T} w (k-1) + \beta^\mathsf{T} w (k).\label{zek3}
\end{align}
%
\subsubsection{Ticked LTL$_f$ formula}\label{encLTL}
%   
We introduce $\Len+1$ binary variables $z_{\phi}(k) \in \{0,1\}$ for $k \in [0,\ \Len]$ such that $z_{\phi}(k)=1$ if and only if $\pi (k...)$ satisfies $\phi$.
We represent $\textit{ILP}(\phi)$ as the constraints of an ILP problem for the ticked LTL$_f$ formula $\phi$.
The encodings corresponding to the specification $\phi$ can be recursively given as follows.
%
%

\textit{Atomic proposition:} Let $\phi = ap \in AP$ and $v \in \{0, 1\}^N$ be a binary vector such that $v_i = 1$ (the $i$-th component of $v$ is $1$) if and only if $ap \in L(s_i)$. Then, the satisfaction of the formula $\phi$ is encoded as follows: 
\begin{align}
v^\mathsf{T} w(k) &\geq z_\phi (k),\notag\\
v^\mathsf{T} w(k) &< z_\phi (k)+1. \notag
\end{align}

\textit{Negation:} Let $\phi = \neg \psi$. Then, the satisfaction of $\phi$ is encoded as 
\begin{align}\notag
z_\phi (k) = 1 - z_\psi (k). 
\end{align}

\textit{Conjunction:} Let $\phi = \bigwedge^{\Len} _{\ell=1} \psi_\ell$. Then, 
\begin{align}
\label{translate_con}
z_\phi (k) &\leq z_{\psi_\ell} (k),\ \forall \ell \in [1,\ \Len], \notag \\ 
z_\phi (k) & \geq 1-\Len + \sum_{\ell=1}^{\Len} z_{\psi_\ell} (k). \notag
\end{align}

\textit{Disjunction:} Let $\phi = \bigvee^{\Len} _{\ell=1} \psi_\ell$. 
Then, 
\begin{align}
z_\phi (k) &\geq z_{\psi_\ell} (k),\ \forall \ell \in [1,\ \Len], \notag \\ 
z_\phi (k) & \leq \sum_{\ell=1}^{\Len} z_{\psi_\ell} (k). \notag
\end{align}
%%%
With a slight abuse of notation, Boolean operators are used for binary variables. For example, when we consider $\phi = \bigwedge^\Len _{\ell=1} \psi_\ell$, we write $z_\phi = \bigwedge^{\Len} _{\ell=1} z_{\psi_\ell}$. % instead of \req{translate_con}. 
Then, we describe the translation of the temporal operator \textit{until} with this notation.
%%%

\textit{Until:} 
Let $\phi = \psi_1 U_{[m,n]} \psi_2$. We introduce binary variables $\underline{z}_m (k, j), \overline{z}_n (k, j) \in \{0, 1\}$, for $k, j \in [0,\ \Len]$ with $k\leq j$,
such that $\underline{z}_m (k,j) = 1$ ({\sl resp.} $\overline{z}_n (k, j) = 1$) if and only if $m \leq c (k, j)$ ({\sl resp.} $c(k,j) \leq n$). That is, $c(k, j)$ is encoded as 
\begin{eqnarray}
m - M_c &\leq c (k, j) - M_c \underline{z}_m(k,j) &\leq m - \epsilon, \notag\\ 
\red{(n-1)} + \epsilon  &\leq  c (k, j) + M_c \overline{z}_n(k,j) &\leq \red{(n-1)}+M_c, \notag
\end{eqnarray}
where $M_c$ is a sufficiently large number satisfying $M_c >n$ \red{and $\epsilon$ is a sufficiently small number satisfying $\epsilon<1$.} 
Then, the satisfaction of $\phi$ is encoded as 
\begin{align}%\label{until1}
z_\phi (k) = \bigvee^{\Len} _{j=k} z_\phi (k, j),
\end{align}
where 
\begin{align}%\label{until2}
z_\phi (k, j) = \overline{z}_n (k,j) \wedge  \underline{z}_m (k,j) \wedge z_{\psi_2} (j) \wedge \left(\bigwedge^{j-1} _{\ell=k} z_{\psi_1} (\ell) \right).  \notag 
\end{align}

The encodings for $\Diamond_{[m,n]}$ and $\Box_{[m,n]}$are similarly done from  \req{futureglobal} and are thus omitted. 
%
%
\red{\subsection{Optimization problem}}
%
To represent two points in \rsec{sec:pbm}, we introduce(set) the following objective function. 
\begin{align}\label{j1}
J_\kappa= 
-\kappa\sum_{k=1}^{\Len}z_e(k) + (1-\kappa)\sum_{i=1}^{N} w_{i}\cdot z_{\psi_{i}(0)}, 
\end{align}
Then, we convert \rpbm{pbm2} into the following ILP problem by using the encodings considered in Section \ref{encode}. 
%Then, we find an execution that satisfies the hard constraint and some soft constraints such that the sum of weights of the satisfied soft constraints is maximized with the considering the shortness of time. 
%
%Then, based on the above setting about soft constraints and their weights, 
%
%
\begin{eqnarray}
&\mbox{max: }&J_\kappa \notag \\
&\mbox{subject to: }&\req{w}-\req{ckj},\ \textit{ILP}(\phi),\ \textit{ILP}(\psi_i),\notag\\
&&z_{\phi} (0) = 1, {\rm{for\ each\ }}  i \in [1,\ N].\notag
\end{eqnarray}
%
%
Note that $\kappa$ represents the trade-off between the time for the result of execution and the sum of weight of satisfied soft constraints.
For example, we find the execution with the shortest time without considering soft constraints when $\kappa=1$, and the execution that maximizes the sum of weights of satisfied soft constraints is found without considering the time when $\kappa=0$.

The procedures to solve \rpbm{pbm2} is described in Algorithm 1 in detail. 
%
%
%
\begin{algorithm}
\caption{: FIND($G,\phi,\Psi,\Len,J_\kappa$): algorithm to solve \rpbm{pbm2}} \label{alg_solve_maxsat}
\begin{algorithmic}
%
\Require $G$, $\phi$, $\Psi=\{(\psi_i,weight);\ i\in[1,\ N]\}$, $\Len$, $J_\kappa$
\Ensure a finite execution $\pi$ 

\State Get $A$, $\alpha$, $\beta$ from a transition function of $G$

\State Set \req{w}-\req{zek3} 
\State Convert $\phi$ to \textit{ILP}($\phi$)
\If{$\Psi$ is not empty}

	\For{ $i \in [1,N]$}
	\State Convert $\psi_{i}$ to \textit{ILP}($\psi_{i}$) 
	\State Set $(z_{\psi_i}(0)=1,weight_i)$ as a soft constraint
	\EndFor
\EndIf
\State Set the objective function $J_\kappa$
\State Find an execution of $G$
\If{Succeed to find an execution}
	\State Return the execution 
\Else
	\State  Return $\bot$
\EndIf
\end{algorithmic}
\end{algorithm}
%
%%
%

%
In order to demonstrate effectiveness to partition the formula in \rpbm{pbm2}, 
we show an illustrative example of path planning and discuss how the optimal path depends on the weights for the soft constraints in the following section.
%

%
\subsection{Example}\label{sec:sim1}
%
In this section, we demonstrate the effectiveness of the proposed approach by a simulation of a path planning problem for a mobile robot.
\red{The simulation was run by a machine with AMD Ryzen9 5950X and 128GB memory, and the solver Gurobi\footnote{https://www.gurobi.com/} was used to compute an optimal solution of this ILP problem.}
%
\subsubsection{Setting of TDES}
\label{settingDES}
%
%
\begin{figure}
\centering 
\includegraphics[width=8cm]{1-c4-crop.pdf}
\caption{The untimed DES $G_{act}$ considered in \rsec{sec:sim1}.}
\label{sim1}
\end{figure}
%
We consider the system whose logical behavior is modeled by an untimed DES $G_{act}$ shown in \rfig{sim1}.
In the figure, each node represents the state of the system, and each edge represents the transition between them. 
The symbol $(e,l_e,u_e)$ near each edge represents the event  $e\in\Sigma_{act}$ associated with the edge, the lower time of $e$, and the upper time of $e$, respectively. The element in parentheses next to $s_i$ represents atomic propositions assigned to $s_i$ for $i\in[0,~5]$.
The initial state is $s_0$.
%
Based on the above definitions, the corresponding timed DES $G$ is constructed according to \rdef{def:G}. 
%
\subsubsection{Simulation result}
%
We consider the following hard constraint, and soft constraints and their weight.
\begin{align}
\phi=&\F{0,\Len}p_{fin},\notag \\
\Psi 
=&\{
(\psi_1=\G{0,\Len}(\lnot p_s),3),~
(\psi_2=\F{0,\Len}p_3,1),\notag \\
&~~(\psi_3=\F{0,\Len}p_4,1),~
(\psi=((\lnot p_4) \U{0,\Len} p_3,2)
\}.\notag
\end{align}
%
We use Gurobi to compute an optimal execution that optimizing the objective function $J_\kappa$. 
Let $\Len=20$. We compute optimal executions $\pi^1$, $\pi^2$, and $\pi^3$ with $\kappa=0.01,~0.5,1$, respectively, such that $\Pr(\pi^1)$, $\Pr(\pi^2)$, and $\Pr(\pi^3)$ are given by
\begin{align}
\Pr(\pi^1)=&
s_0,\ttick,s_0,\ttick,s_0,e_{03},s_3,\ttick,s_3,\ttick,\notag\\
&s_3,e_{34},s_4,\ttick,s_4,e_{40},s_0,e_{01},s_1,\notag\\
&\ttick,s_1,e_{12},s_2,\ttick,s_2,e_{25},s_5,\ldots,s_5\notag\\
\Pr(\pi^2)=&
s_0,\ttick,s_0,\ttick,s_0,e_{03},s_3,\ttick,\notag\\
&s_3,\ttick,s_3,e_{35},s_5,\ldots,s_5\notag \\
\Pr(\pi^3)=&s_0,e_{01},s_1,\ttick,s_1,e_{12},s_2,\ttick,s_2,e_{25},s_5,\ldots,s_5\notag
\end{align}
%
The time for $\pi^1$, $\pi^2$, and $\pi^3$ are 7, 4, and 2 [\tick], respectively.
The sum of weight of soft constraints satisfied by $\pi^1$, $\pi^2$, and $\pi^3$ are 4, 3, and 0.
The results of executions are shown that the combination of satisfied soft constraints is changed when the value of $\kappa$ is changed while satisfying the hard constraint.
%
\end{comment}
%
\section{Hierarchical TDESs}\label{def:htdes}
%
\red{In this section, we introduce a novel hierarchical timed discrete event system (HTDES). In the case where the specification is very complicated, a hierarchical specification is a practically useful. For example, we consider a mobile robot in a manufacturing system with many assembling machines and a specification gives constraints for both its movement and scheduling of assembling a product. Then, we introduce an atomic proposition ``assembling a product'' in the specification for the movement because the robot moves to a machine that can assemble the product.  Then, we also describe the assembling operation by a pair of a TDES and a formula, where the TDES models a behavior of the machine and the formula describes a constraint for the assembling. See Section V-B for the detail. Such a planning problem is formulated using a hierarchical model where an atomic proposition at the upper-level TDES model is refined as a pair of a TDES and a formula at its lower-level model, where the granularity of the unit time at the lower-level TDES is finer than that of the upper-level TDES because the specification of the lower-level TDES is a refinement of an atomic proposition at the upper-level TDES. For simplicity, we focus on a three-level HTDES which is composed of a top-level, a middle-level, and a bottom-level TDES with a specification. }
%
%
%階層プランニングはボトムアップのプランニングである。なので、まず下位TDESをProblem 1に従って、プランニングを行う。このとき、いくつかのαの値で実行列を求め、そのそれぞれについて、かかった時間とソフト制約の重みの合計を上位TDESに情報として与える。その情報をもとに上位TDESのプランニングを行う

In a three-level HTDES, a DES at the top level is denoted by $G_{act}$.
$G_{act}$ is given by $G_{act}=(S_{act},\Sigma_{act},\delta_{act},s_{init,act},AP_{act},L_{act})$.
%
$S_{act}$ is the set of states, $\Sigma_{act}$ is the set of events, $\delta_{act}$ is the transition function, $s_{init,act}$ is the initial state, $AP_{act}$ is the set of atomic propositions and $L_{act}$ is its corresponding labeling function.
In our proposed HTDES, each lower-level TDESs describes detailed behavior for the corresponding atomic proposition of its upper-level TDES.
We call these atomic propositions \textit{refined atomic propositions} and atomic propositions other than refined atomic propositions \textit{unrefined atomic propositions}.
Then, we assume that the set of atomic propositions $\AP_{act}$ is partitioned into two sets $\AP_{act}^{R}$ and $\AP_{act}^{N}$.
The atomic propositions in $\AP_{act}^{R}$ and $\AP_{act}^{N}$ are refined atomic proposition and unrefined atomic proposition, respectively.
%
$\AP_{act}^R$ and $\AP_{act}^N$ are given by
\begin{eqnarray}
\AP_{act}^R&=&\{\textit{p}_1,\textit{p}_2,\ldots,p_{M}\}, \notag \\
\AP_{act}^N&=&\{\textit{p}_{M+1},\textit{p}_{M+2},\ldots,p_{|\AP_{act}|}\},\notag 
\end{eqnarray}
%
with the following assumption.
%
\begin{align}
\AP_{act}=\AP_{act}^R \cup \AP_{act}^N,~
\AP_{act}^R \cap \AP_{act}^N=\emptyset.\notag
\end{align}
%
For every $i \in [1,\ M]$, detailed behavior of(corresponding to) $p_i$ is represented by a middle-level TDES, denoted by $G_{i,act}$. 
$G_{i,act}$ is given by $G_{i,act}=(S_{i,act},\Sigma_{i,act},\delta_{i,act},s_{init,i,act},AP_{i,act},L_{i,act})$ for $i \in [1,\ M]$.
$S_{i,act}$ is the set of states, $\Sigma_{i,act}$ is the set of events, $\delta_{i,act}$ is the transition function, $s_{init,i,act}$ is the initial state, $AP_{i,act}$ is the set of atomic propositions and $L_{i,act}$ is its corresponding labeling function.
%
As with $G_{act}$, we introduce refined atomic propositions and unrefined atomic propositions for $G_{i,act}$ ($i \in [1,\ M]$) whose sets are denoted by $\AP_{i,act}^R$ and $\AP_{i,act}^N$.
Then, $\AP_{i,act}^R$ and $\AP_{i,act}^N$ are given by
\begin{eqnarray}
\AP_{i,act}^R&=&\{\textit{p}_{i,1},\textit{p}_{i,2},\ldots,p_{i,M_i}\},\notag\\
\AP_{i,act}^N&=&\{\textit{p}_{i,M_i+1},\textit{p}_{i,M_i+2},\ldots,p_{|\AP_{i,act}|}\},\notag
\end{eqnarray}
%
with the following assumption.
%
\begin{align}
&\AP_{i,act}=\AP_{i,act}^R \cup \AP_{i,act}^N,~
\AP_{i,act}^R \cap \AP_{i,act}^N=\emptyset,\notag\\
&\AP_{act}^R \cap \AP_{i,act}^R =\emptyset.\notag
\end{align}
Then, we introduce a TDES $G_{i,j_i,act}$ for detailed behavior of a refined proposition $p_{i,j_i}$ for every $i\in[1,~M]$ and $j_i\in [1,~M_i]$.
$G_{i,j_i,act}=(S_{i,{j_i},act}$, $\Sigma_{i,{j_i},act},\delta_{i,{j_i},act},s_{init,i,{j_i},act},AP_{i,{j_i},act},L_{i,{j_i},act})$ is given in the same way as $G_{act}$ and $G_{i,act}$.
\red{Note that the family of event sets $\Sigma_{act}$, $\Sigma_{i, act}$, $\Sigma_{i,j,act}$ is pairwise disjoint.}

\begin{comment}

In the middle level, there are $M$ TDESs denoted by $G_{i,act}$ for $i \in [1,\ M]$.
At the bottom level, there are $M_i$ TDESs, denoted by $G_{i,{j_i},act}$ for $j_i\in [1,~M_i]$, whose corresponding TDES at next upper-level is $G_{i,act}$ for each $i \in [1,\ M]$.
$G_{act}$ is given by $G_{act}=(S_{act},\Sigma_{act},\delta_{act},s_{init,act},AP_{act},L_{act})$.
Moreover, for $i \in [1,\ M]$ and $j_i\in [1,~M_i]$, $G_{i,act}$ is given by $G_{i,act}=(S_{i,act},\Sigma_{i,act},\delta_{i,act},s_{init,i,act},AP_{i,act},L_{i,act})$, and $G_{i,{j_i},act}$ is given by $G_{i,{j_i},act}=(S_{i,{j_i},act}$, $\Sigma_{i,{j_i},act},\delta_{i,{j_i},act},s_{init,i,{j_i},act},AP_{i,{j_i},act},L_{i,{j_i},act})$.
%
$S_{act}$, $S_{i,act}$, and $S_{i,{j_i},act}$ are the sets of states, $\Sigma_{act}$, $\Sigma_{i,act}$, and $\Sigma_{i,{j_i},act}$ are the sets of events, $\delta_{act}$, $\delta_{i,act}$, and $\delta_{i,{j_i},act}$ are the transition functions, $s_{init,act}$, $s_{init,i,act}$, and $s_{init,i,{j_i},act}$ are the initial states, $AP_{act}$, $AP_{i,act}$, and $AP_{i,{j_i},act}$ are the sets of atomic propositions and $L_{act}$, $L_{i,act}$, and $L_{i,{j_i},act}$ are their corresponding labeling functions.

%(We assume that $\Sigma_{act} \cap \Sigma_{i,act} = \emptyset,\Sigma_{i,act} \cap \Sigma_{i',act} = \emptyset$ for any $i,i'\in[1,\ M],\ i\neq i'$.)
%

%
%
In our proposed HTDES, TDESs correspond to atomic propositions of the next upper-level TDES.
Then, we assume that the set of atomic propositions $\AP_{act}$ ({\sl resp.} $\AP_{i,act}$) is partitioned into two sets $\AP_{act}^{R}$ and $\AP_{act}^{N}$ ({\sl resp.} $\AP_{i,act}^{R}$ and $\AP_{i,act}^{N}$).
The states where atomic propositions in $\AP_{act}^{R}$ and $\AP_{act}^{N}$ ({\sl resp.} $\AP_{i,act}^{R}$ and $\AP_{i,act}^{N}$) are assigned are refined and unrefined states, respectively.
%
$\AP_{act}^R$, $\AP_{act}^N$, $\AP_{act}^R$, and $\AP_{act}^N$ are given by
\begin{eqnarray}
\AP_{act}^R&=&\{\textit{p}_1,\textit{p}_2,\ldots,p_{M}\}, \notag \\
\AP_{act}^N&=&\{\textit{p}_{M+1},\textit{p}_{M+2},\ldots,p_{|\AP_{act}|}\},\notag \\
\AP_{i,act}^R&=&\{\textit{p}_{i,1},\textit{p}_{i,2},\ldots,p_{i,M_i}\}, \notag \\
\AP_{i,act}^N&=&\{\textit{p}_{i,M_i+1},\textit{p}_{i,M_i+2},\ldots,p_{|\AP_{i,act}|}\},\notag
\end{eqnarray}
%
with the following assumption.
%
\begin{eqnarray}
\AP_{act}=\AP_{act}^R \cup \AP_{act}^N,&&
\AP_{act}^R \cap \AP_{act}^N=\emptyset,\notag\\
\AP_{i,act}=\AP_{i,act}^R \cup \AP_{i,act}^N,&&
\AP_{i,act}^R \cap \AP_{i,act}^N=\emptyset,\notag\\
\AP_{act}^R \cap \AP_{i,act}^R =\emptyset.&&\notag
\end{eqnarray}
%
For each state corresponding to $\textit{p}_i \in \AP_{act}^{R}$ ({\sl resp.} $p_{i,{j_i}}\in \AP_{i,act}^{R}$), we have a middle-level DES $G_{i, act}$ ({\sl resp.} a bottom-level DES $G_{i,{j_i}, act}$) that models its local behaviors.


\end{comment}

%
%According to \rsec{tdes}, we introduce TDESs corresponding to $G_{act}$, $G_{i,act}$, and $G_{i,{j_i},act}$ that are denoted by $G$, $G_{i}$, and $G_{i,{j_i}}$, respectively.
%

The granularity of the unit time of each system may be different, so its unit time is also different. 
We distinguish each unit time and introduce a corresponding special event that means the elapse of one unit time as follows.
%
Denoted by \tick$_p$ is a unit time of $G_{act}$, each \tick$_i (i\in[1,\ M])$ is a unit time of $G_{i,act}$, and each \tick$_{i,{j_i}} (i\in[1,\ M], j_i\in[1,\ M_i])$ is a unit time of $G_{i,{j_i},act}$. Then,  events $\textit{tick}_p$, $\textit{tick}_i$, and $\textit{tick}_{i,{j_i}}$ means the elapse of \tick$_p$, \tick$_{i}$, and \tick$_{i,{j_i}}$, respectively.
%
%
%
%
Timer interval $T_\sigma$, $T_{i,\sigma_i}$, and $T_{i,{j_i},\sigma_{i,{j_i}}}$ for each $\sigma\in\Sigma_{act}$, $\sigma_i\in\Sigma_{i,act}$, and $\sigma_{i,{j_i}}\in\Sigma_{i,{j_i},act}$ is given in the basis of \tick$_p$, \tick$_i$, and \tick$_{i,{j_i}}$, respectively.
%
%
Then, we denote the DES together with the corresponding unit time and the corresponding timer interval by
\begin{eqnarray}
\overline{G}&\coloneqq&(G_{act},\mbox{\tick}_p,\{T_{\sigma} |~\sigma\in \Sigma_{act} \}),\notag\\
 \overline{G_i}&\coloneqq&(G_{i,act},\mbox{\tick}_i,\{T_{i,\sigma} |~\sigma\in \Sigma_{i,act} \}),\notag\\
\overline{G_{i,{j_i}}}&\coloneqq&(G_{i,{j_i},act},\mbox{\tick}_{i,{j_i}},\{T_{i,{j_i},\sigma} |~\sigma\in \Sigma_{i,j_i,act} \}),\notag
\end{eqnarray}
respectively, where $i\in [1,\ M]$ and $j_i\in [1,\ M_i]$.
According to \rdef{def:G}, the TDES $G$ corresponding to $\overline{G}$ is given by a tuple $G=(S,\Sigma,\delta,s_{init},AP,L)$, for each $i\in[1,\ M]$, a TDES $G_i$ corresponding to $\overline{G_i}$ is given by a tuple $G_i=(S_{i},\Sigma_{i},\delta_{i},s_{init,i},AP_{i},L_{i})$, and, for each $i\in[1,\ M]$ and $j_i\in[1,\ M_i]$, a TDES $G_{i,{j_i}}$ corresponding to $\overline{G_{i,{j_i}}}$ is given by a tuple $G_{i,j_i}=(S_{i,{j_i}},\Sigma_{i,{j_i}},\delta_{i,{j_i}},s_{init,i},AP_{i,{j_i}},L_{i,{j_i}})$.
%
$S$, $S_i$, and $S_{i,{j_i}}$ are the sets of states, $\Sigma$, $\Sigma_i$, and $\Sigma_{i,{j_i}}$ are the sets of events, $\delta$, $\delta_i$, and $\delta_{i,{j_i}}$ are the transition functions, $s_{init}$, $s_{init,i}$, and $s_{init,i,{j_i}}$ are the initial states, $\AP$, $\AP_i$, and $\AP_{i,{j_i}}$ are the sets of atomic propositions and $L$, $L_i$, and $L_{i,{j_i}}$ are their corresponding labeling functions.
%
Executions of the $G$, $G_{i}$, and $G_{i,{j_i}}$ are given in the same way as \req{execution}. 
%
%
Then, we denote the three-level HTDES as follows. 
%
\begin{align}\label{htdes}
\mathcal{G}
=&\{\overline{G}, \overline{G_i}, \overline{G_{i,{j_i}}} \},
\end{align}
where $i\in[1,\ M]$ and $j_i\in[1,\ M_i]$.
%
%
\begin{exa}\label{exa:hier}
Consider a three-level HTDES consists of TDESs corresponding to DESs shown in \rfig{ex:htdes}.
For the top-level DES $G_{act}$, there are two states $s_1$ and $s_2$.
We set $\AP^R_{act}=\{p_1,p_2\}$ and $\AP^N_{act}=\{p_3\}$. Then, atomic propositions are assigned to each state as follows.
\[
L_{act}(s_{1}) = \{p_1,p_3\},~
L_{act}(s_{2}) = \{p_1,p_2\}.
\]
If $s_1$ or $s_2$ is stayed at in a top-level plan, a middle-level plan determined by the TDES $G_1$ corresponding to $G_{1,act}$ can be implemented.
If $s_2$ is stayed at in a top-level plan, both middle-level plans determined by $G_1$ and $G_2$ can be implemented in parallel.
For the middle-level DESs $G_{1,act}$ and $G_{1,act}$, we set a set of atomic propositions and label functions as follows. 
\begin{gather}
\AP^R_{1,act}=\{p_{1,1}\},~\AP^N_{1,act}=\{p_{1,2}\},
\notag\\
\AP^R_{2,act}=\{p_{2,1}\},~\AP^N_{2,act}=\{p_{2,2}\},
\notag\\
L_{1,act}(s_{1}^1) = \{p_{1,1}\},~
L_{1,act}(s_{2}^1) = \{p_{1,2}\},
\notag\\
L_{2,act}(s_{1}^2) = \{p_{2,2}\},~
L_{2,act}(s_{2}^2) = \{p_{2,1}\},
\notag\\
L_{2,act}(s_{3}^2) = \{p_{2,1}\}.\notag
\end{gather}
Then, there are two bottom-level DESs $G_{1,1,act}$ and $G_{2,1,act}$ corresponding to $p_{1,1}$ and $p_{2,1}$, respectively.
\qedwhite
\end{exa}
%
\begin{figure}
\centering
\includegraphics[width=8cm]{ex_htdes_2-crop.pdf}
\caption{The HTDES considered in Example \ref{exa:hier}.}
\label{ex:htdes}
\end{figure}
%
%
%
\red{\subsection{Complexity(kari)}}
%
%
%

%
\section{Hierarchical planning}\label{sec:hplan}
%


%So, we first compute several candidates of a bottom-level plan with a finer time scale for each state of the middle-level TDES using the corresponding bottom-level TDES such that the plan is optimal for the corresponding objective function. Then, we find several candidates of a middle-level plan for the middle-level specification using the middle-level TDES such that a bottom-level plan at each refined state is determined(decided) of the candidates and all determined bottom-level plans are feasible under the middle-level plan. Finally, we find an optimal top-level plan and determine a middle plan at each refined state for the top-level specification using the top-level TDES such that all middle plans are feasible under the top-level plan.
We propose optimal hierarchical planning for a three-level HTDES introduced in the previous section with specification given for every TDES.
Our proposed planning is based on a bottom-up approach such that every lower-level planer computes candidates of a plan for the its upper-level planning, then the upper-level planer selects one of candidates \red{for every time that refined atomic propositions are true} to optimize its cost function.


For each TDES, we consider a planning problem with a specification consisting of one hard constraint and some soft constraints, where all constraints are described by ticked LTL$_f$ formulas. %, such that a plan is an execution satisfying the hard constraint and soft constraints as fast as possible.
For $G$, $G_i$, and $G_{i,j_i}$, hard constraints are denoted by $\phi$, $\phi^i$, and $\phi^{i,j_i}$, respectively, and soft constraints are denoted by $\psi_1,...,\psi_N$, $\psi_1^i,...,\psi_{N_i}^i$, and $\psi_1^{i,j_i},...,\psi_{N_{i,j_i}}^{i,j_i}$ with the number of soft constraints $N$, $N_i$, and $N_{i,j_i}$, respectively. 
We assume that there is a preference for each soft constraint, that is, if there is no execution that satisfies both $\psi_i$ and $\psi_j$ but there are executions that satisfy one of them, then, as a plan, we select an execution that satisfies the more preferable constraint.  For $G$, to represent the preference, we introduce a positive integer $w_n$, called a {\sl weight}, for each soft constraint $\psi_n (n \in [1,N])$ and interpret that $\psi_n$ is more preferable than $\psi_m$ if $w_n >w_m$. 
In the same way, we introduce $w_{n_i}^i (n_i \in [1,N_i])$ and $w_{n_{i,j_i}}^{i,j_i} (n_{i,j_i} \in [1,N_{i,j_i}])$ for $G_i$ and $G_{i,j_i}$, respectively.
Thus, an execution for which the sum of the weights of the satisfied soft constraints is larger is a more preferable one.
We denote a set of pairs of a soft constraint and its weight by $\Psi=\{(\psi_n, w_n)|~n\in[1,~N]\}$, $\Psi^i=\{(\psi_n^i, w_n^i)|~n\in[1,~N_i]\}$, and $\Psi^{i,j_i}=\{(\psi_n^{i,j_i}, w_n^{i,j_i})|~n\in[1,~N_{i,j_i}]\}$ for $G$, $G_i$, and $G_{i,j_i}$, respectively.

%the sum of weights of soft constraints that $\pi(J)$ satisfies.
We introduce $\pi(J)$ as an execution of a TDES $G'$ which optimizes an objective function $J$.
Let ${\tick}_{l}$ and ${\tick}_u$ be a unit time of the TDES $G'$ and one of its upper-level TDES, respectively.
$m_{\pi(J)}$ is defined as the time for $\pi(J)$ with respect to ${\tick}_{u}$ and given by
\begin{align}\label{ti}
m_{\pi(J)}=\left\lceil \left(\textit{count}_{\pi(J)}(0,\Len)+1\right)\cdot\frac{{\tick}_l}{{\tick}_{u}} \right\rceil,
\end{align}
where $\Len$ is a given length for $\pi(J)$, $(\textit{count}_{\pi(J)}(0,\Len)+1 )$ represents the time for $\pi(J)$ with respect to ${\tick}_l$, and $\lceil x \rceil =\min\{n\in\mathbb{Z}|\ x\leq n\}$.
Let $W_{\pi(J)}$ be the reward which is given for implementation of $\pi(J)$ at its upper-level plan. 
For example, $W_{\pi(J)}$ is the sum of weights of soft constraints satisfied by $\pi(J)$ or the optimal value of $J$. 
$m_{\pi(J)}$ and $W_{\pi(J)}$ are used when a planer selects one of candidates of its lower-level plan.
Then, we consider what kinds of performance indexes are needed for each level planning.

In the bottom-level planning, we compute executions of $G_{i,{j_i}}$ as candidates of a bottom-level plan for each $i\in[1,~M]$ and $j_i\in[1,~M_i]$.
%
Since we introduce the soft constraints to a planning problem, we have two performance indexes $J_{time}^{i,j_i}$ and $J_{soft}^{i,j_i}$ for a plan: $J_{time}^{i,j_i}$ indicates how fast the plan is completed and $J_{soft}^{i,j_i}$ indicates how large the sum of the preferences of the satisfied soft constraints is.
Then, a preferable plan minimizes $J_{time}^{i,j_i}$ and maximizes $J_{soft}^{i,j_i}$ simultaneously, which causes a trade-off between the indexes. 
To represent the trade-off, we introduce the following objective function $J_{\kappa}$ with $0 \leq \kappa \leq 1$.
\begin{equation}
J_{\kappa}=-\kappa J_{time}^{i,j_i} + (1-\kappa) J_{soft}^{i,j_i}.
\end{equation}
The parameter $\kappa$ represents which index is more important.
%
To compute candidates of a plan, we find executions of $G_{i,{j_i}}$ with some values of $\kappa$ since the results of execution are different when we change the value of $\kappa$.
%
A set of $\kappa$ is denoted as $K$ and given by
$K=\{\kappa_1,\ldots,\kappa_{|K|}\}$ with $\kappa_i< \kappa_j$ for $i,j\in [1,~|K|],~i\neq j$.
%\red{Additionally, we set $\kappa_{|K|}=1$ since for each bottom-level TDES, the candidate of plan that satisfies a hard specification in the fastest time is practically necessary when the middle-level plan determines a bottom-level plan of candidates.}
%
%We give a hard constraint $\phi_{i,{j_i}}$ and a set of pairs of soft constraint and its weight $\Psi_{i,{j_i}}=\{(\psi_{i,j_i,n},w_{i,j_i,n})|~n\in [1,N_{i,j_i}]\}$ to $G_{i,{j_i}}$ for each $i\in[1,~M]$ and each $j_i\in[1,~M_i]$.
The result of execution of $G_{i,{j_i}}$ with the given length $\Len_{i,{j_i}}$ is denoted by $\pi_{i,{j_i}}(J_\kappa)$ which satisfies $\phi_{i,{j_i}}$ and optimizes the objective function $J_\kappa$.
%
%
Then, we define $\mathcal{M}_i$ and $\mathcal{W}_i$ as follows.
\begin{align}
\mathcal{M}_i&=\{m_{\pi_{i,{j_i}}(J_\kappa)}|~j_i\in[1,~M_i],~\kappa\in K\},\\
\mathcal{W}_i&=\{W_{\pi_{i,{j_i}}(J_\kappa)}|~j_i\in[1,~M_i],~\kappa\in K\}.
\end{align}
%

In the middle-level planning, we have three performance indexes $J_{time}^i$, $J_{soft}^i$, and $J_{lower}^i$.
$J_{time}^i$ and $J_{soft}^i$ have the same meanings as $J_{time}^{i,j_i}$ and $J_{soft}^{i,j_i}$, respectively.
$J_{lower}^i$ indicates how large the sum of rewards of completed bottom-level plans is.
The value of $J_{lower}$ is determined by $\M_i$ and $\W_i$.
To represent a trade-off among $J_{time}^i$, $J_{soft}^i$, and $J_{lower}^i$, we introduce the objective function as follows.
\[
J_{\lambda,\M_i,\W_i}=-\lambda_1 J_{time}^i + \lambda_2J_{lower}^i+ (1-\lambda_1-\lambda_2)J_{soft}^i,
\]
where $0\leq\lambda_1,{\lambda}_2\leq1$, $\lambda_1+{\lambda}_2\leq1$, and $\lambda$ denotes the pair of $\lambda_1$ and $\lambda_2$.
The parameter $\lambda_1$ and ${\lambda}_2$ represent which indexes are more important.
%
%The parameter $\lambda_1$ represents the importance of $J_{time}$, and $\lambda_2$ represents the importance of $J_{lower}^i$. Moreover, $1-\lambda_1-\lambda_2$ represents the importance of $J_{soft}^i$.
We denote a set of some $\lambda$ by $\Lambda$, respectively.
Then, we compute candidates of a plan represented by $\pi_{i}(J_{\lambda,\M_i,\W_i})$ for $\lambda\in\Lambda$ ($|\Lambda|>1$) and each $i\in[1,~M]$.
%Then, we define an objective function $J_{\lambda}$ with parameters in $\lambda\in\Lambda$ for middle-level TDESs, and 
Then, we define $\mathcal{M}$ and $\mathcal{W}$ as follows.
\begin{align}
\mathcal{M}&=\{m_{\pi_{i}(J_{\lambda,\M_i,\W_i})}|~i\in[1,~M],~\lambda\in \Lambda\},\\
\mathcal{W}&=\{W_{\pi_{i}(J_{\lambda,\M_i,\W_i})}|~i\in[1,~M],~\lambda\in \Lambda\}.
\end{align}
%

In the top-level planning, we have three performance indexes $J_{time}$, $J_{soft}$, and $J_{lower}$ in the same way as the middle-level planning.
Then, we find a trajectory of $G$ with a length $\Len$ and the specification given to $G$ while optimizing the following objective function.
%We assume that the top-level planning does not need to consider the time for the result of an execution.Then, there are two performance indexes $J_{soft}$ and $J_{lower}$ in the top-level planning.
%We denote a ratio of the importance of $J_{lower}$ to $J_{soft}$ by $\mu$ with $0\leq\mu\leq1$, and the objective function for the top-level planning is as follows.
\[
J_{\mu,\M,\W} = \mu_1 J_{time}+ \mu_2 J_{lower} + (1-\mu_1-\mu_2)J_{soft},
\]
where $0\leq\mu_1,{\mu}_2\leq1$, $\mu_1+{\mu}_2\leq1$, and $\mu$ denotes the pair of $\mu_1$ and $\mu_2$.
These $\mu_1$ and $\mu_2$ represent trade-off among $J_{time}$, $J_{lower}$, and $J_{soft}$.

In summary, we consider the following problem to find a plan of a three-level HTDES.
\begin{pbm}\label{pbm3}
Given a three-level HTDES $\mathcal{G}$, a hard constraint, denoted by $\phi$, $\phi_i$ and $\phi_{i,{j_i}}$, and a set of pairs of a soft constraint and its weight, denoted by $\Psi$, $\Psi_i$ and $\Psi_{i,{j_i}}$, for $G$, $G_i$ and $G_{i,{j_i}}$, respectively, the length $\Len(>0)$, $\Len_i(>0)$ and $\Len_{i,{j_i}}(>0)$ for $G$,  $G_i$ and $G_{i,{j_i}}$, respectively, parameters for objective functions $K$, $\Lambda$ and $\mu$, and objective functions $J_\kappa$, $J_{\lambda}$ and $J_{\mu}$, \red{find an overall plan of $\mathcal{G}$ by the following procedure.
%
\begin{enumerate}
\item
Find several candidates of a bottom-level plan  %represented by executions $\pi_{i,{j_i}}(J_\kappa)$ of 
using $G_{i,j_i}$ for every $i\in [1,~M]$, $j_i\in [1,~M_i]$,  and all $\kappa\in K$
such that 
\begin{eqnarray}
&\mbox{max: }&J_\kappa \notag \\
&\mbox{subject to: }&\pi_{i,{j_i}}(J_\kappa)\models \phi_{i,{j_i}},\notag% \mbox{ and } SYS(G_{i,{j_i}}).\notag 
\\&&\mbox{transition lows of }G_{i,{j_i}}.\notag 
\end{eqnarray}
%
%
%
\item
Find several candidates of a middle-level plan using $G_i$ for every $i\in [1,~M]$ and all $\lambda\in \Lambda$ 
such that there is a feasible bottom-level plan for every time $p_{i,j_i}$ is true for every $j_i\in [1,~M_i]$, and
\begin{eqnarray}
&\mbox{max: }&J_{\lambda,\M_i,\W_i}\notag \\
&\mbox{subject to: }&\pi_i(J_{\lambda,\M_i,\W_i})\models \phi_i,\notag% \mbox{ and } SYS(G_{i}).\notag
 \\&&\mbox{transition lows of }G_i.\notag 
\end{eqnarray}
%
\item
Find a top-level plan using the top-level TDES $G$  such that there is a feasible bottom-level plan for every time $p_{i}$ is true for every $i\in [1,~M]$, and
\begin{eqnarray}
&\mbox{max: }&J_{\mu,\M,\W}\notag \\
&\mbox{subject to: }&\pi(J_{\mu,\M,\W})\models \phi,\notag% \mbox{ and } SYS(G).\notag
\\&&\mbox{transition lows of }G.\notag 
\end{eqnarray}
\end{enumerate}
}
%
%
%
\qedwhite
\end{pbm}
%

We convert \rpbm{pbm3} into the following ILP problems by using the encodings considered in Section \ref{encode}. 
First, for the bottom-level planning, the ILP problem {\bf ILP\ref{pbm3}-1} to find $w_{G_{i,j_i}}(k)\in\{0,1\}^{|S_{i,j_i}|}$ ($k=[0,~\Len_{i,j_i}]$) for each $i\in[1,~M]$ and $j_i \in [1,M_i]$ is given by
%
\begin{eqnarray}
\mbox{\bf ILP\ref{pbm3}-1}: &\mbox{maximize }&J_\kappa \notag \\
&\mbox{subject to }&SYS(G_{i,j_i}), \notag \\
&& LTL(\phi^{i,j_i}),\notag \\
&& LTL(\psi^{i,j_i}_n) \  {\rm{for\ each\ }}  n \in [1,\ N_{i,j_i}], \notag\\
&& w_{G_{i,j_i}}(0)=w_{G_{i,j_i},s_0}, \notag \\
&&z_{\phi_{i,j_i}} (0) = 1. \notag
\end{eqnarray}
Next, for the middle-level planning, the ILP problem {\bf ILP\ref{pbm3}-2} to find $w_{G_i}(k)\in\{0,1\}^{|S_i|}$ ($k=[0,~\Len_i]$) for each $i\in[1,~M]$ is given by
\begin{eqnarray}
\mbox{\bf ILP\ref{pbm3}-2}: 
&\mbox{maximize }&J_{\lambda,\M_i,\W_i} \notag \\
&\mbox{subject to }&SYS(G_i), \notag \\
&& LTL(\phi^i),\notag \\
&& LTL(\psi^{i}_n) \  {\rm{for\ each\ }}  n \in [1,\ N_i], \notag\\
&& w_{G_i}(0)=w_{G_i,s_0}, \notag \\
&&z_{\phi_i} (0) = 1. \notag
\end{eqnarray}
%
Finally, for the top-level planning, the ILP problem {\bf ILP\ref{pbm3}-3} for finding $w_G(k)\in\{0,1\}^{|S|}$ ($k=[0,~\Len]$) is given by
%
\begin{eqnarray}
\mbox{\bf ILP\ref{pbm3}-3}: 
&\mbox{maximize }&J_{\mu,\M,\W} \notag \\
&\mbox{subject to }&SYS(G), \notag \\
&& LTL(\phi),\notag \\
&& LTL(\psi_n) \  {\rm{for\ each\ }}  n \in [1,\ N], \notag\\
&& w_G(0)=w_{G,s_0}, \notag \\
&&z_{\phi} (0) = 1. \notag
\end{eqnarray}
%
We obtain candidates $w_{G_{i,j_i}}$ and $w_{G_i}$ for all $\kappa\in K$ and all $\lambda\in \Lambda$ by solving {\bf ILP\ref{pbm3}-1} and {\bf ILP\ref{pbm3}-2}, respectively.
Note that, if there are no feasible solutions of the ILP problem {\bf ILP\ref{pbm3}-1}, {\bf ILP\ref{pbm3}-2}, and {\bf ILP\ref{pbm3}-3}, there are no plan satisfying the hard constraint.  In such a case, we denote $\pi_{i,j_i}=\bot$, $\pi_i=\bot$, and $\pi=\bot$.
Additionally, if $\pi_{i,j_i}=\bot$ ({\sl resp.} $\pi_{i}=\bot$), we update $\AP_i$ and $L_i$ ({\sl resp.} $\AP$ and $L$) such that $\AP_i\leftarrow \AP_i\setminus \{p_{i,j_i}\}$ ({\sl resp.} $\AP\leftarrow \AP\setminus \{p_{i}\}$) and $L_i(s)\leftarrow L_i(s)\setminus \{p_{i,j_i}\}$ ({\sl resp.} $L(s)\leftarrow L(s)\setminus \{p_{i}\}$) for all $s\in S_{i}$ ({\sl resp.} $s\in S$).

The procedures to solve each ILP problem and Problem \ref{pbm3} are described in Algorithm \ref{alg_solve_maxsat} and Algorithm \ref{alg2} in detail, respectively.
%

%
%
\begin{algorithm}
\caption{: FIND($G,\phi,\Psi,\Len,J$): algorithm for finding an optimal plan of \red{a TDES}. } \label{alg_solve_maxsat}
\begin{algorithmic}
%
\Require $G$, $\phi$, $\Psi=\{(\psi_n,{w_n});\ n\in[1,\ N]\}$, $\Len$, $J$.
\Ensure a finite execution $\pi$.

\State Get $A$, $\alpha$, $\beta$ from a transition function of $G$.

\State Set \req{w}-\req{zek3}.
\State Convert $\phi$ to $LTL$($\phi$).
\If{$\Psi$ is not empty}

	\For{ $n \in [1,N]$}
	\State Convert $\psi_n$ to $LTL$($\psi_n$).
	\State Set $(z_{\psi_n}(0)=1,{w_n})$ as a soft constraint.
	\EndFor
\EndIf
\State Set the objective function \red{$J$}.
\State Find an optimal execution of $G$ for \red{{\bf ILP\ref{pbm3}-1}, {\bf ILP\ref{pbm3}-2}, or {\bf ILP\ref{pbm3}-3}.}
\If{Succeed to find an execution}
	\State Return the execution as an optimal plan.
\Else
	\State  Return $\bot$.
\EndIf
\end{algorithmic}
\end{algorithm}
%



\begin{algorithm}
\caption{Hierarchical planning: algorithm for finding an overall plan of a HTDES.} \label{alg2}
\begin{algorithmic}
%
\Require $\mathcal{G}$, hard constraints: $\phi$, $\phi^i$, and $\phi^{i,j_i}$, a sets of pairs of a soft constraint and its weight: $\Psi$, $\Psi^i$, and $\Psi^{i,j_i}$, the length: $\Len$, $\Len_i$, and $\Len_{i,j_i}$, cost functions: $J_\kappa$, $J_{\lambda}$ and $J_{\mu}$, and parameters: $K$, $\Lambda$ and $\mu$.
\Ensure a finite execution of the top-level TDES $\pi$.
%
\State $\mathcal{M}=\emptyset,\mathcal{W}=\emptyset$
\For{ $i \in \{1,\ldots,M\}$}
\For{ $j \in \{1,\ldots,M_i\}$}
	\For{ $\kappa\in K$}
		\State ${\pi_{i,j_i}(\kappa)}$ = Find($G_{i,j_i},\phi^{i,j_i},\Psi^{i,j_i}\Len_{i,j_i},J_\kappa$).
		\If{${\pi_{i,j_i}(\kappa)}=\bot$}
		\State \red{$\AP_i\leftarrow \AP_i\setminus \{p_{i,j_i}\}$.}
		\State \red{$L_i(s)\leftarrow L_i(s)\setminus \{p_{i,j_i}\}$ for all $s\in S_i$.}
		\Else
		\State $m_{\pi_{i,j_i}(\kappa)}$
		\State \hspace{0.8cm}$=\left\lceil (\textit{count}_{\pi_{i,j_i}(\kappa)}(0,\Len_{i,j_i})+1)\frac{\tick_{i,j_i}}{\tick_i} \right\rceil $.
		\State Get $W_{\pi_{i,j_i}(\kappa)}$ from $\pi_{i,j_i}(\kappa)$.
		\State $\mathcal{M}_i=\mathcal{M}_i\cup\{m_{\pi_{i,j_i}(\kappa)}\}$.
		\State $\mathcal{W}_i=\mathcal{W}_i\cup\{W_{\pi_{i,j_i}(\kappa)}\}$.
		\EndIf
	\EndFor
\EndFor
\EndFor
\For{ $i \in \{1,\ldots,M\}$}
\For{ $\lambda\in \Lambda$}
		\State ${\pi_i(\lambda)}$ = Find($G_i,\phi^i,\Psi^i,\Len_i,J_{\lambda,\M_i,\W_i}$).
		\If{${\pi_{i}(\lambda)}=\bot$}
		%\State $\AP\leftarrow\AP\setminus \{p_i\}$.
		\State \red{$\AP\leftarrow \AP\setminus \{p_{i}\}$.}
		\State \red{$L(s)\leftarrow L(s)\setminus \{p_{i}\}$ for all $s\in S$.}
		\Else
		\State $m_{\pi_i(\lambda)}=\left\lceil (\textit{count}_{\pi_i(\lambda)}(0,\Len_i)+1)\frac{\tick_i}{\tick_p} \right\rceil $.
		\State Get $W_{\pi_i(\lambda)}$ from $\pi_i(\lambda)$.
		\State $\mathcal{M}=\mathcal{M}\cup\{m_{\pi_i(\lambda)}\}$, $\mathcal{W}=\mathcal{W}\cup\{W_{\pi_i(\lambda)}\}$.
		\EndIf
\EndFor
\EndFor
%
\State ${\pi}$ = Find($G,\phi,\Psi,\Len,J_{\mu,\M,\W}$).
\end{algorithmic}
\end{algorithm}
%
%$\AP_i\leftarrow \AP_i\setminus \{p_{i,j_i}\}$ ({\sl resp.} $\AP\leftarrow \AP\setminus \{p_{i}\}$) and $L_i(s)\leftarrow L_i(s)\setminus \{p_{i,j_i}\}$ ({\sl resp.} $L(s)\leftarrow L(s)\setminus \{p_{i}\}$)
%
%
\section{Illustrative example of hierarchical planning}\label{simResult}
%
%
%
We show an illustrative example of planning for a mobile robot modeled by a three-level HTDES. % introduced above section.
We introduce objective functions considered in this section concretely.
Then, the effectiveness of the proposed approach is demonstrated by numerical simulation.
%


\subsection{Objective function}
%
%We introduce the objective functions we consider in this simulation concretely.
We simply denote $J_{\lambda,\M_i,\W_i}$ and $J_{\mu,\M,\W}$ as $J_{\lambda}$ and $J_{\mu}$, respectively.
We first introduce the performance indexes of the objective function $J_\kappa$ for the bottom-level planning. 
Based on the binary variables used in encoding of a trajectory of each $G_{i,j_i}$ and the ticked LTL${}_f$ formula $\psi^{i,j_i}_n$, $J_{time}^{i,j_i}$ and $J_{soft}^{i,j_i}$ in $J_{\kappa}$ are given by
\begin{align}\label{obj:1}
J_{time}^{i,j_i}=\sum_{k=1}^{\Len_{i,j_i}}z_e(k),~ J_{soft}^{i,j_i}=\sum_{n=1}^{N_{i,j_i}} w_{n}^{i,j_i}\cdot z_{\psi_{n}^{i,j_i}}(0), 
\end{align}
where $z_e(k)=1$ means that the $k$-th event of the execution is $\ttick_{i,j_i}$ and $z_{\psi_{n}^{i,j_i}}(0)=1$ means that the plan satisfies the soft constraint $\psi_{n}^{i,j_i}$.
Note that $J_{time}^{i,j_i}$ indicates the number of the event $\ttick_{i,j_i}$ in the execution corresponding to the plan and $J_{soft}^{i,j_i}$ is the sum of the preferences of the soft constraints satisfied by the plan. 
%

Next, we consider the performance indexes of the objective function $J_\lambda$ for the middle-level planning.
Based on the binary variables used in encoding of a trajectory of each $G_{i}$ and the ticked LTL${}_f$ formula $\psi^{i}_n$, $J_{time}^i$ and $J_{soft}^i$ in $J_{\lambda}$ are given in the same way as $J_{time}^{i,j_i}$ and $J_{soft}^{i,j_i}$ in $J_{\kappa}$ as follows. 
\begin{align}\label{obj:2}
J_{time}^{i}=\sum_{k=1}^{\Len_{i}}z_e(k),~ J_{soft}^{i}=\sum_{n=1}^{N_{i}} w_{n}^{i}\cdot z_{\psi_{n}^{i}}(0).
\end{align}
%
\begin{comment}
Then, we consider $J_{lower}^i$ that indicates the sum of rewards of completed bottom-level plans.
One of candidates $\pi_{i,j_i}(J_\kappa)$ for $\kappa\in K$ can be selected when $z_{p_{i,{j_i}}}(k)=1$ for $j_i\in[1,~M_i]$. 
To represent which plan is selected at the $k$-th state of the trajectory of $G_i$, we introduce $\Len_i + 1$ binary variables $y_{p_{i,{j_i}},\kappa}(k)\in\{0,~1\}$ for $k\in[0,~\Len_i]$, $i\in[1,~M]$, $j_i\in[1,~M_i]$, and $\kappa\in K$.
Only if $p_{i,{j_i}}$ is true at the $k$-th state, i.e., $z_{p_{i,{j_i}}}(k)=1$, $y_{p_{i,{j_i}},\kappa}(k)=1$ that  represents that the bottom-level plan of $G_{i,{j_i}}$ determined by $\pi_{i,j_i}(J_\kappa)$ is selected at the $k$-th state.
To represent when and which bottom-level plan is \red{put into action}, we introduce $\Len_i + 1$ binary variables ${y}^{i,j_i}_{\kappa}$ as follows.
\begin{align}
y^{i,j_i}_{\kappa}
=\G{0,m_{\pi_{i,j_i}(J_\kappa)}} y_{p_{i,j_i},\kappa}.\label{hier2-1}
\end{align}
For each $k\in[0,~\Len_i]$, ${y}^{i,j_i}_{\kappa}(k)=1$ represents that the bottom-level plan determined by $\pi_{i,j_i}(J_\kappa)$ is \red{put into action} from the $k$-th state of $\pi_i(J_\lambda)$ until $m_{\pi_{i,j_i}(J_\kappa)}$ is passed.
Since each bottom-level TDES represents detailed behavior of a task(system?), e.x., a detailed procedure of an operation, one of candidates have to be completed for every stay at the states where refined atomic propositions are assigned.
Then, $y_{p_{i,{j_i}},\kappa}(k)$ satisfy the following equations.
\begin{align}\label{hier1}
%{y}_{p_{i,{j_i}},\kappa}(k) \leq z_{p_{i,{j_i}}}(k).
\sum_{\kappa\in K}{y}_{p_{i,{j_i}},\kappa}(k) = z_{p_{i,{j_i}}}(k),~\mbox{for }\forall k\in[0,~\Len_i].
\end{align}
%

\end{comment}
\red{Then, we consider $J_{lower}^i$ that indicates the sum of rewards of completed bottom-level plans.
To represent when and which bottom-level plan is put into action, we introduce $\Len_i + 1$ binary variables ${y}^{i,j_i}_{\kappa}$.
For each $k\in[0,~\Len_i]$, ${y}^{i,j_i}_{\kappa}(k)=1$ represents that the bottom-level plan determined by $\pi_{i,j_i}(J_\kappa)$ is put into action from the $k$-th state of $\pi_i(J_\lambda)$ until $m_{\pi_{i,j_i}(J_\kappa)}$ is passed.
$y^{i,j_i}_{\kappa}$ satisfy the following equation.
\begin{align}
y^{i,j_i}_{\kappa}
=\G{0,m_{\pi_{i,j_i}(J_\kappa)}} y_{p_{i,j_i},\kappa},\label{hier2-1}
\end{align}
where $y_{p_{i,j_i},\kappa}(k)$ for $k\in [0,~\Len_i + 1]$ are $\Len_i + 1$ binary variables and defined by 
\begin{align}\label{hier:y}
y_{p_{i,j_i},\kappa}(k)=\left\{ \begin{array}{ll}
1 & \mbox{$\pi_{i,j_i}(J_\kappa)$ is ongoing at }s(k), \\
0 & \mbox{otherwise.}
\end{array} \right. ,
\end{align}
and satisfy the following equation.
\begin{align}\label{hier1}
\sum_{\kappa\in K}{y}_{p_{i,{j_i}},\kappa}(k) = z_{p_{i,{j_i}}}(k),~\mbox{for }\forall k\in[0,~\Len_i].
\end{align}
From \req{hier:y}, $y_{p_{i,{j_i}},\kappa}(k)=1$ that  represents that the bottom-level plan of $G_{i,{j_i}}$ determined by $\pi_{i,j_i}(J_\kappa)$ is ongoing at the $k$-th state.
\req{hier1} represents one of candidates $\pi_{i,j_i}(J_\kappa)$ for $\kappa\in K$ can be selected when $p_{i,{j_i}}$ is true at the $k$-th state, i.e., $z_{p_{i,{j_i}}}(k)=1$ for $j_i\in[1,~M_i]$.
}

Additionally, we introduce $\Len_i + 1$ binary variables $y^{i,j_i}_{{imp}}$.
$y^{i,j_i}_{{imp}}$ represents the constraint such that one of candidates of a bottom-level plan is done from the state where $p_{i,j_i}$ changes from false to true. 
%since it takes $m_{\pi_{i,{j_i}}(J_\kappa)}$ [$\tick_i$] to implement the plan determined by $\pi_{i,{j_i}}(J_\kappa)$.
%Once ${y}^{i,j_i}_{\kappa}=1$, ${y}^{i,j_i}_{\kappa}=0$ from the next state until the procedure is finished, i.e., $m_{\pi_{i,j_i}(J_\kappa)}$ $[\tick_i]$ passes.
%
Then, $y^{i,j_i}_{{imp}}$ satisfy the following equations.
%
\begin{eqnarray}
y^{i,j_i}_{{imp}}(0)~~ &=& z_{p_{i,{j_i}}}(0) \Leftrightarrow\bigvee_{\kappa\in K} {y}^{i,j_i}_{\kappa}(0),\label{hier2-2-0}\\
y^{i,j_i}_{{imp}}(k+1) &=& (\lnot z_{p_{i,{j_i}}}(k))\land (z_{p_{i,{j_i}}}(k+1)) 
\notag\\&&~\Leftrightarrow\bigvee_{\kappa\in K} {y}^{i,j_i}_{\kappa}(k+1),\label{hier2-2}
\end{eqnarray}
where $k\in[0,~\Len_{i,j_i}-1]$.
%
\begin{exa}
We consider the following execution of the TDES corresponding to $G_{2,act}$ of Example \ref{exa:hier}.
\begin{align}
\Pr(\pi_{2,\lambda})
=&s^2_1,\sigma_{1,2},s^2_2,\ttick_2,s^2_2,\sigma_{21},\notag \\
&s^2_1,\sigma_{1,3},s^2_3,\ttick_2,s^2_3,\ttick_2,s^2_3,\notag
\end{align}
where $\sigma_{i,j}\in\Sigma_{2,act}$ for $i,j\in[1,3],i\neq j$, $s^2_j=\delta_{2,act}(s_i^2,\sigma_{i,j})$, and timer intervals for all events are given by $[0,~\infty]$.
There are $\kappa_1$ and $\kappa_2$, and we have $m_{\pi_{i,j_i}(J_{\kappa_1})}=1$ and $m_{\pi_{i,j_i}(J_{\kappa_2})}=2$.
In $\pi_{2,\lambda}$, the plan determined by $\kappa_1$ ({\sl resp.} $\kappa_2$) is done when $s^2_2$  ({\sl resp.} $s^2_3$) is stayed at.
When $s^2_3$ is stayed at, the plan determined by $\kappa_1$ can not be done twice because of $\lnot z_{p_{i,{j_i}}}(k))\land (z_{p_{i,{j_i}}}(k+1)$ in \req{hier2-2}.
\qedwhite
\end{exa}
%
In this simulation, let the reward for $\pi(J)$, denoted by $W_{\pi(J)}$, be the sum of weights of soft constraints that $\pi(J)$ satisfies.
%
Then, we introduce $J_{lower}$ in the objective function $J_{\lambda}$ for $G_i$ with ${y}^{i,{j_i}}_\kappa$ as follows.
\begin{align}\label{obj:3}
J_{lower}^i=\sum_{j_i\in[1,~M_i]} \sum_{\kappa\in K} \sum_{k=0}^{\Len_i} {y}^{i,{j_i}}_\kappa(k) \cdot {W_{\pi_{i,{j_i}}(J_\kappa)}}.
\end{align}
%
We determine $J_\lambda$ with \req{obj:2} and \req{obj:3}, and add the constraints \req{hier1}-\req{hier2-2} to the constraint of {\bf ILP\ref{pbm3}-2}.

\begin{comment}

Then, we introduce the objective function $J_{\lambda}$ for $G_i$ with ${z}^{i,{j_i}}_\kappa$ as follows.
\begin{align}
J_{\lambda}=&
-\lambda_1\sum_{k=1}^{\Len_i}z_e(k) 
\notag\\&~
+
{\lambda_2}\left(\sum_{j_i\in[1,~M_i]} \sum_{\kappa\in K} \sum_{k=0}^{\Len_i} {y}^{i,{j_i}}_\kappa(k) \cdot {W_{\pi_{i,{j_i}}(J_\kappa)}}\right)
\notag\\&~
+
(1-{\lambda_1}-{\lambda_2})\left(\sum_{n=1}^{N_i} w^i_{n}\cdot z_{\psi^i_{n}}(0)\right) ,\notag
\end{align}
where $\Psi_i=\{(\psi^i_n,w_n^i)|~n\in[1,N_i]\}$ is a set of $N_i$ pairs of soft constraint and its weight for $G_i$.
%
%


\end{comment}

%
Finally, we consider the performance indexes of $J_\mu$ for the top-level planning.
In the same way as $y_{p_{i,{j_i}},\kappa}$ , ${y}^{i,j_i}_{\kappa}$, and $y^{i,j_i}_{{imp}}$, we introduce  $\Len + 1$ binary variables $y_{p_{i},\lambda}$ , ${y}^{i}_{\lambda}$, and $y^{i}_{{imp}}$, respectively.
%$z_{p_i,\lambda}(k)$, $z_\lambda^i$, and $z^{i}_{\phi_\lambda} $
These variables satisfy the following equations.
\begin{align}
%&{y}_{p_{i},\lambda}(k) \leq z_{p_{i}}(k)., \label{hier2-1}\\
%
&\sum_{\lambda\in \Lambda}{y}_{p_{i},\lambda}(k)= z_{p_{i}}(k), \label{hier:t-1}\\
%
%&\sum_{\lambda\in \Lambda}{y}_{p_{i},\lambda}(k) = 1,~\mbox{for }\forall k\in[0,~\Len_i],\label{hier2-2}\\
%
&y^{i}_{\lambda}
=\G{0,m_{\pi_{i}(J_\lambda)}} y_{p_{i},\lambda},\label{hier:t-3}\\
&y^{i}_{{imp}}(k) = \lnot z_{p_{i}}(k)\land (z_{p_{i}}(k+1)) \Leftrightarrow\bigvee_{\lambda\in \Lambda} {y}^{i}_{\lambda}(k+1).\label{hier:t-4}
\end{align}
%
In the same way as \req{obj:1}, \req{obj:2}, and \req{obj:3}, we introduce $J_{time}$, $J_{soft}$, and $J_{lower}$ in the basis of the binary variables used in encoding of a trajectory of $G$ and the ticked LTL${}_f$ formula $\psi_n$, and $y^i_\lambda$ as follows.
\begin{align}\label{obj:4}
&J_{time}=\sum_{k=1}^{\Len}z_e(k),
~J_{soft}=\sum_{n=1}^{N} w_{n}\cdot z_{\psi_{n}}(0).\\
&J_{lower}=\sum_{i\in[1,~M]} \sum_{\lambda\in\Lambda} \sum_{k=0}^{\Len} {y}^i_\lambda
(k) \cdot W_{\pi_i(\lambda)}.\label{obj:5}
\end{align}
%
We determine $J_\mu$ with \req{obj:4} and \req{obj:5}, and add the constraints \req{hier:t-1}-\req{hier:t-4} to the constraint of {\bf ILP\ref{pbm3}-3}.

%
\subsection{Path planning with tasks}

\begin{figure}
   \centering
   \includegraphics[width=6cm]{p-crop.pdf}
   \caption{Grid model for the top-level DES considered in \rsec{simResult}. The left-top state(location) is $s_{init,act}$, the right-top state is $s_{5,act}$, the left-bottom state is $s_{30,act}$ and the right-bottom state is $s_{35,act}$. Atomic propositions assigned to green, red, yellow, and grey states are $p_1$, $p_2$, $p_3$, and $p_4$, respectively.}
    \label{pTDES}
    %\vspace{0.1cm}
\end{figure}
\begin{figure}
   \centering
    \subfigure[The DES $G_{act,1}$ corresponding to $p_1\in \AP_{act}$.]{\hspace{0cm}
      {\includegraphics[width=6cm]{c1-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,2}$ corresponding to $p_2\in \AP_{act}$.]{\hspace{0cm}      {\includegraphics[width=8cm]{c2_2-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,3}$ corresponding to $p_3\in \AP_{act}$.]{\hspace{0cm}
      {\includegraphics[width=7cm]{c3-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
    \caption{The untimed DESs used for the middle-level planning in the simulation of \rsec{simResult}. Each DES represents task procedure or behaviors of a system. Each node represents the state of the task, and each edge represents the transition between them. The element in parentheses in each state represents atomic propositions assigned to the state. The symbol $(e,l_e,u_e)$ near each edge represents the event  $e$ associated with the edge, the lower time of $e$, and the upper time of $e$.   } \label{cTDES}
    %\vspace{0.1cm}
\end{figure}
%

We consider a path planning problem where a robot moves the areas while doing tasks which is assigned to the corresponding states.
In the top-level planning, we consider an order to visit states that represent locations.
In the middle-level planning, we determine plans to operate procedures of tasks. 
Then, in bottom-level planning, we determine plans of procedures in detail.
%
%
First, for the top-level planning, we introduce a DES $G_{act}$ for modeling behaviors of the robot 
 with the coarse granularity of the unit time as shown in \rfig{pTDES}.
%
The $G_{act}$ is represented by a $6\times6$ grid where $S_{act}=\{s_{act,0},s_{act,1},\ldots,s_{act,{34}},s_{act,{35}}\}$, and there is a transition between $s_{act,i}$ and $s_{act,j}$ if and only if $s_{act,i}$ and $s_{act,j}$ are adjacent locations horizontally or vertically with the events $\textit{up}_i$, $\textit{down}_i$, $\textit{left}_i$, or $\textit{right}_i$.
%In the figure, each grid represents a state and, for every state $s_i$, there are transitions between $s_i$ and the states connected to $s_i$ horizontally or vertically .
%
The initial state $s_{init,act}$ is the left-top state $s_0$.
$\AP_{act}=\{p_i|~i\in[0,5]\}$ is the set of atomic propositions and the labeling function $L_{act}$ is given by
\begin{align}
&L_{act}(s_{ 10 }) =  p_1,\
L_{act}(s_{19}) =  p_1, \notag \\
&L_{act}(s') = p_2,\mbox{ for } s'\in\{s_3,s_4,s_5,s_{10},s_{11},s_{17}\}, \notag\\
&L_{act}(s_{ 31 }) = p_3,\ 
L_{act}(s_{ 34 }) =  p_3, \ 
L_{act}(s_{ 63 }) =  p_4,\notag\\
&L_{act}(s) =  p_5\mbox{ for other states.}%s\in S_{act}\setminus\{s_{ 12 },s_{ 14 },s_{30},s_{33},s_{34},s_{50},s_{63}\}.
\end{align}
We define $\AP_{act}^R=\{p_1,p_2,p_3\}$ and $\AP_{act}^N=\{p_4,p_5\}$ 
The time scale of $G_{act}$ is given by ${\tick}_p=100$, and, for every $\sigma\in \Sigma$, the timer interval is given by $T_\sigma=[1,\infty]$ in the basis of ${\tick}_p$.
%
%
Then, we introduce DESs for modeling procedures of tasks (behaviors of systems) used in middle-level planning as shown in \rfig{cTDES}.
We introduce three DESs, for $i=1,2,3$, $G_{i,act}=(S_{i,act}, \Sigma_{i,act}, \delta_{i,act},s_{init,i,act}, L_{i,act}, A_{i,act})$ corresponding to $p_i\in \textit{AP}$, respectively.
For $i=1,2,3$ and $j\in[0,\ |S_{i,act}|]$, the element in parentheses next to $s_j^i$ represents atomic propositions assigned to $s_j^i$.
%
The symbol $(e,l_e,u_e)$ near each edge represents the event  $e$ associated with the edge, the lower time of $e$, and the upper time of $e$.
We set $\AP_{1,act}^R=\{p_{1,1}\}$, $\AP_{2,act}^R=\{p_{2,1}\}$, and $\AP_{3,act}^R=\{p_{3,1},p_{3,2}\}$
%

%
$G_{1,act}$ represents a procedure to \textit{load a luggage}. At the states $s_{1,1}$ and $s_{1,2}$ where the atomic proposition $p_{1,1}$ is assigned, luggage is   loaded in the robot.
$G_{2,act}$ represents a Solar power generation system. 
The atomic proposition $p_{2,1}$ assigned to $s_1^2$ represents the state of checking battery.
$G_{3,act}$ represents two procedures using the same machine, and these two procedures can not be operated at the same time.
The atomic proposition $p_{3,1}$ assigned to $s_1^3$ and $s_3^3$ represents the state of using the machine.
At the states $s_2^3$ and $s_4^3$ where the atomic proposition $p_{3,2}$ is assigned, the machine is cleaned up.

%
%
%
%
The unit time $\tick_i$ of $G_{i,act}$ for each $i=1,2,3$ are given by
\begin{align}
&{\tick}_1=80,~{\tick}_2=90,~{\tick}_3=80,\notag\\
{\tick}_{1,1}=&70,~{\tick}_{2,1}=60,~{\tick}_{3,1}=70,~{\tick}_{3,2}=50,\notag
\end{align}
respectively.
%
%

\begin{figure}
   \centering
    \subfigure[The DES $G_{act,1,1}$ corresponding to $p_{1,1}\in \AP_{1,act}$.]{\hspace{0cm}
      {\includegraphics[width=6cm]{l_1_1-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,2,1}$ corresponding to $p_{2,1}\in \AP_{2,act}$.]{\hspace{0cm}      {\includegraphics[width=5cm]{l_2_1-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,3,1}$ corresponding to $p_{3,1}\in \AP_{3,act}$.]{\hspace{0cm}
      {\includegraphics[width=7cm]{l_3_1-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,3,2}$ corresponding to $p_{3,2}\in \AP_{3,act}$.]{\hspace{0cm}
      {\includegraphics[width=7cm]{l_3_2-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
    \caption{The untimed DESs used for the bottom-level planning in the simulation of \rsec{simResult}. Each DES represents task procedure or behaviors of a system.  } \label{l:TDES}
    %\vspace{0.1cm}
\end{figure}
%
Finally, we introduce DESs for modeling procedures(behaviors) of systems used in the bottom-level planning as shown in \rfig{l:TDES}.
%
From the above settings for DESs, we have the three-level HTDES with eight TDESs. 
%
\subsection{Specifications for hierarchical planning}
%
To determine a hierarchical plan for the robot, we give a specification for each TDES.
For the top-level TDES $G$, a hard constraint $\phi$ and a set of pairs of a soft constraint and its weight $\Psi$ are given by
\begin{align}
\phi=&\F{0,\Len}\G{0,2}p_1\land \F{0,\Len}\G{0,3}p_3\land (\lnot p_3)\U{0,\Len}p_1, \notag \\
\Psi=&\{
(\psi_1=\G{1,5}\lnot p_4, 2), ~
(\psi_2=\F{0,\Len}\G{0,2}p_2, 1),\notag\\&~
(\psi_3=\F{0,\Len}\G{0,4}p_2, 2),~
(\psi_4=\F{0,\Len}\G{0,4}p_3, 3),\notag\\&~
(\psi_5=\F{0,\Len}(p_1\land p_2),1)
\}.\notag
\end{align}
%
A hard constraint $\phi^i$ and a set of pairs of a soft constraint and its weight $\Psi^i$ for each $G_i$ are as follows, respectively.
\begin{align}
\phi^1=&\F{0,\Len_1}p_{1,5},\notag \\
\Psi^1 
=&\{
(\psi^1_{1} =\F{0,\Len_1}p_{1,4}, 1),~
(\psi^1_{2} =\F{0,\Len_1}\G{0,5}p_{1,3},2),\notag\\
&~(\psi^1_{3} =\F{0,\Len_1}\G{0,5}p_{1,4},1), \notag\\
&~(\psi^1_{4} =(\lnot p_{1,4}) \U{0,\Len_1}p_{1,3}, 2)
\} ,\notag
\\
\phi^2=&\F{0,\Len_2}p_{4},\notag \\
\Psi^2
=&\{
(\psi^2_{1}=\F{0,\Len_2}\G{0,4}p_{2,3},2)\notag\\
&~
(\psi^2_{2}=\F{0,\Len_2}\G{0,4}(\lnot p_{2,1}),1),\notag\\
&~(\psi^2_{3}=\G{0,\Len_2}\{(\lnot p_{2,3}) \lor (\lnot\F{0,\Len_2}p_{2,1})\},1)
\},\notag
\\ % r はready
\phi^{3}=&\F{0,\Len_3}p_{3,6},\notag \\
\Psi^3
=&\{
(\psi^3_{1}=\F{0,\Len_3}p_{3,4}, 3),~
(\psi^3_{2}=(\G{4,6}\lnot p_{3,5}, 2),\notag \\&~
(\psi^3_{3}=(\F{0,\Len_3}(\G{0,3}p_{3,2}), 3),\notag \\&~
(\psi^3_{4}=(\lnot p_{3,5})\U{0,5}p_{3,4}, 2)
\} .
\notag
\end{align}
%
Then, a hard constraint $\phi^{i,{j_i}}$ and a set of pairs of a soft constraint and its weight $\Psi^{i,{j_i}}$ for each $G_{i,{j_i}}$ are as follows, respectively.
%
\begin{align}
\phi^{1,1}=&\F{0,\Len_{1,1}}p_{1,1,4},\notag \\
\Psi^{1,1} 
=&\{
(\psi^{1,1}_1 =\F{0,\Len_{1,1}}p_{1,1,3}, 2),~
(\psi^{1,1}_2 =\F{0,5}p_{1,1,4},3),\notag\\
&~(\psi^{1,1}_4 =(\lnot p_2^{1,1}) \U{0,\Len_{1,1}}p_3^{1,1}, 2)
\} ,\notag
\\
%
%
\phi^{2,1}=&\F{0,\Len_{2,1}}p_{2,1,4},\notag \\
\Psi^{2,1} 
=&\{
(\psi^{2,1}_1=\F{0,\Len_{2,1}}\G{0,4}p_{2,1,3},2),\notag \\&~
(\psi^{2,1}_2=\F{0,\Len_{2,1}}\G{0,5}(\lnot p_{2,1,3}),1),\notag\\&~
(\psi^{2,1}_3= \lnot p_{2,1,2} \lor \F{3,15}(\lnot p_{2,1,2}),1)
\},\notag
\\ % r はready
\phi^{3,1}=&\F{0,\Len_{3,1}}p_{3,1,5},\notag \\
\Psi^{3,1} 
=&\{
(\psi^{3,1}_1=\F{0,\Len_{3,1}}(\G{0,4}p_{3,1,1}, 2),\notag \\
&~(\psi^{3,1}_2=(\F{0,\Len_{3,1}}(p_{3,1,4}\land \F{0,4}p_{3,1,2}), 3),\notag \\
&~(\psi^{3,1}_3=\F{0,\Len_{3,1}}p_{3,1,3}, 2),\notag \\
&~
(\psi^{3,1}_4=\G{3,6}(\lnot p_{3,1,2}), 3)
\} ,
\notag \\
\phi^{3,2}=&\F{0,\Len_{3,2}}p_{3,2,5} ,\notag \\
\Psi^{3,2} 
=&\{
(\psi^{3,2}_1=\F{0,\Len_{3,2}}\G{0,5}p_{3,2,3}, 3),\notag \\
&~
(\psi^{3,2}_2=\G{0,\Len_{3,2}}(\lnot p_{3,2,2}\lor\F{0,\Len_{3,2}}(\lnot p_{3,2,3})), 2),\notag \\
&~(\psi^{3,2}_3=\F{0,\Len_{3,2}}p_{3,2,3}, 1),~
(\psi^{3,2}_4=\G{2,5}\lnot p_{3,2,4}, 2)\}
 .\notag
\end{align}
%
%
%
\subsection{Results}
%
The length of execution for each TDES is given by
\begin{align*}
\Len = 30,~\Len_1=15,&~\Len_2=18,~\Len_3=20,
\\
\Len_{1,1} = 12,~\Len_{2,1}=15,&~\Len_{3,1}=20,~\Len_{3,2}=20.
\end{align*}
Let $K=\{1,~0.5,~0.01\}$ and $\Lambda=\{(1.0,~0),~(0.33,~0.33),~(0.1,~0.1)\}$. 
Additionally, $(1.0,~0)$, $(0.33,~0.33)$, and $(0.1,~0.1)$ are denoted by $\lambda_1$, $\lambda_2$, and $\lambda_3$, respectively.
%, and $\mu=0.5$.
%
We compute executions of the bottom-level TDESs for each $\kappa\in K$.
Then, we compute executions of the middle-level TDESs for each $\lambda\in\Lambda$.
In Table \ref{tab:mw}, we show the time for each results of execution and the sum of weight of soft constraints that the execution satisfies.
{\renewcommand\arraystretch{1.5}
\begin{table}[h]
\caption{The time for each results of execution, denoted by Time, and the sum of weight of soft constraints that the execution satisfies, denoted by Sum of weights.
}\label{tab:mw}
\begin{subfigmatrix}{2}
\subtable[The result of the bottom-level TDESs. Time and $W$ are equal to $m_{\pi_{i,j_i}(J_\kappa)}$ and $W_{\pi_{i,j_i}(J_\kappa)}$, respectively. Soft denotes satisfied soft constraints.]{
\begin{tabular}{c|c|c|c|c}
%
% 
&$\kappa\in K$ & Time  & Soft & $W$\\
\hline
			& 1			& 2 &$\psi^{1,1}_2$&3  \\
$G_{1,1}$ 	& 0.5 	& 2   &$\psi^{1,1}_2$  &3\\
			& 0.01 		& 7 &$\psi^{1,1}_1,\psi^{1,1}_3$&4 \\
\hline			
			& 1			& 4 &$\psi^{2,1}_3$&1   \\
$G_{2,1}$ 	& 0.5 	& 4  &$\psi^{2,1}_2,\psi^{2,1}_3$&2 \\
			& 0.01 		& 5 &All &4  %$\psi^{2,1}_1,\psi^{2,1}_2,\psi^{2,1}_3$ 
			\\
\hline	
			& 1 			& 1 &$\psi^{3,1}_4$ &3  \\
$G_{3,1}$ 	& 0.5 	& 4 &$\psi^{3,1}_2,\psi^{3,1}_3,\psi^{3,1}_4$  &8 
\\
			& 0.01 		& 7 &All&10  %$\psi^{3,1}_1,\psi^{3,1}_2,\psi^{3,1}_3,\psi^{3,1}_4$  
			\\
\hline	
			& 1 			& 3 &$\psi^{3,2}_2$ &2  \\
$G_{3,2}$ 	& 0.5 	& 5 &All &8 \\
			& 0.01 		& 5 &All  &8 \\
\end{tabular}\label{tab:mw:mid}}
%
%  \hfill
  %
\subtable[The result of the middle-level TDESs. Time and $W$ are equal to $m_{\pi_i(J_{\lambda})}$ and $W_{\pi_i(J_{\lambda})}$, respectively. Soft and Task denote satisfied soft constraints and implemented tasks which are  determined by bottom-level plans.]{
\centering
\begin{tabular}{c|c|c|c|c|c}
%
%$W_{\pi_i(J_{\lambda})}$ 
& $\lambda\in \Lambda$& Time&Soft & $W$&Task\\
%(0.1~0.1) (0.33,~0.33), (1,~0)
\hline
			& (1,~0) 		& 3  & $\psi^{1}_4$&2 & \\
$G_1$ 	& (0.33,~0.33) 		& 8 & $\psi^{1}_1,\psi^{1}_4$&3&$\pi_{1,1}(J_{1})$, $\pi_{1,1}(J_{0.5})$  \\
			& (0.1,~0.1)	& 8 & $\psi^{1}_1,\psi^{1}_4$&3  &$\pi_{1,1}(J_{1})$, $\pi_{1,1}(J_{0.5})$ \\
\hline			
			& (1,~0)		& 3 & $\psi^{2}_3$&1  \\
$G_2$ 	& (0.33,~0.33) 		& 6 & $\psi^{2}_2,\psi^{2}_3$&2  &$\pi_{2,1}(J_{0.01})$ \\
			& (0.1,~0.1)	& 9&All   &4  &$\pi_{2,1}(J_{0.01})$ \\
\hline	
			& (1,~0) 		& 5 & $\psi^{3}_2$ &2 \\
$G_3$ 	& (0.33,~0.33) 		& 12 &All&10  &$\pi_{3,1}(J_{1})$, $\pi_{3,2}(J_{0.5})$   \\
			& (0.1,~0.1) 	& 12&All  &10 &$\pi_{3,1}(J_{1})$, $\pi_{3,2}(J_{0.5})$ \\
\end{tabular}\label{tab:mw:bot}}
\end{subfigmatrix}
\end{table}
}
%
In the following, we compute two executions of $G$ with $\mu=0.1$ and $0.5$.
Note that satisfaction soft constraints is more important than implementation of tasks determined by bottom-level plans when we set $\mu=0.1$.

For each value of $\mu$, the path of robot determined by the execution is shown in shown in \rfig{p:result}, and satisfied soft constraints, the sum of weights of them and implemented tasks are in Table \ref{tab:p}.

When $\mu=0.1$, all soft constraints are satisfied, and tasks determined by the executions of $G_1$, $G_2$, and $G_3$ are implemented.
However, every task satisfies only the hard constraint with the minimum required time and do not implemented any bottom-level tasks. 
On the other hand, when $\mu=0.5$, satisfied soft constraints are $\psi_1$ and $\psi_4$ and tasks determined by $G_1$ and $G_3$.
Since the execution with $\mu=0.5$ focuses on the  implementation of tasks is  more than that with $\mu=0.1$
Since the implementation of tasks is as important as the satisfaction of soft constraints when $\mu = 0.5$, the task determined by $\pi_3(J_{\lambda_3})$ is implemented.

The robot stays at $s_{10,act}$ between [\tick] and [\tick] and implements the task determined by $\pi_{}$ and $\pi_{}$.
Then, the robot moves to $s_{34,act}$.

\begin{figure}
   \centering
   \includegraphics[width=6cm]{p_result_mu-01-05-crop.pdf}
   \caption{The path determined by the result of execution. Black ({\sl resp.} blue) arrows represents the path optimizing the objective function with $\mu=0.1$ ({\sl resp.} $\mu=0.5$). The numbers in four grids represent the time the robot stays at the grids.}
    \label{p:result}
    %\vspace{0.1cm}
\end{figure}
%
%
\begin{table}
\caption{The result of the top-level TDESs. Soft, $W$, and Task are denote satisfied soft constraints, the sum of weights of them, and implemented tasks.}
\label{tab:p}
\centering
\begin{tabular}{c|c|c|ccc}
 $\mu$ &Soft& $W$&Task\\\hline
0.1& All &9 &  $\pi_1(J_{\lambda_1})$, $\pi_2(J_{\lambda_1})$, $\pi_3(J_{\lambda_1})$\\
0.5& $\psi_1$, $\psi_4$  &5 & $\pi_1(J_{\lambda_1})$, $\pi_3(J_{\lambda_3})$\\
\end{tabular}
\end{table}
%
%
\begin{comment}
%
%
\begin{figure}
   \centering
    \subfigure[The path optimizing the cost function with $\mu=0.1$.]{\hspace{0cm}
      {\includegraphics[width=5cm]{p_result_mu-01-crop.pdf}\hspace{0.0cm}} \label{p:r:01}} \vspace{0.0cm}
      \subfigure[The path optimizing the cost function with $\mu=0.5$.]{\hspace{0cm}      {\includegraphics[width=5cm]{p_result_mu-05-crop.pdf}\hspace{0.0cm}} \label{p:r:05}} \vspace{0.0cm}
    \caption{The path determined by the result of execution. } \label{p:result}
    %\vspace{0.1cm}
\end{figure}



\section{efficiency of our method(kari)}
%
In this section, we consider(confirm) the efficiency of our proposed method.
We consider three (cases of a) three-level HTDES $\mathcal{G}_1$, $\mathcal{G}_2$, $\mathcal{G}_3$, and $\mathcal{G}_4$.
$\mathcal{G}_i$ for all $i=[1,~4]$ have one top-level TDES $G$.
In $\mathcal{G}_i$ for $i=[1,~4]$, there are one, one, two, and two middle-level TDESs $G_i$, and one, two, three and four bottom-level TDESs, respectively.
We introduce TDESs of $\mathcal{G}_i$ for $i=[1,~4]$ as follows.

In every TDES of each HTDES, there are four states and transitions between pairs of states that are different from each other.
We define the initial state and the final state states, then the two states other than the initial state and the final state are defined as refined states.
There is a transition from the final state to the final state, called \textit{self transition}.
The unit time of the top-level TDES, middle-level TDESs, and bottom-level TDESs are given by 40, 20, and 10, respectively.
In the basis of the unit time of each TDES, a timer interval for the  self transition is given by $[0,\infty]$ and those for other events are given by $[1,\infty]$.
For each TDES, a hard constraint represents ``the final state  is eventually achieved''.
Additionally, soft constraints represents ``the state $s$ is eventually achieved '' where $s$ is a state of the TDES other than the initial state and the final state, and weights of all soft constraints is 1.

For comparison, we introduce a TDES $\tilde{G}_i$ corresponding to $\mathcal{G}_i$ for $i=[1,~4]$.
In $\tilde{G}_i$, two types of transitions are added.
The first is a transition from each refined state to  the initial state of the corresponding next lower-level TDES. 
The second is a transition from each final state to the refined state of the corresponding next upper-level TDES.
The unit time of every $\tilde{G}_i$ is given by 10.
Then, the timer intervals of events corresponding to these two types of transitions are given by $[0,\infty]$.
Additionally, timer intervals of events of the top-level TDES ({\sl resp.} middle-level TDESs), originally, are given by $[4,~\infty]$ ({\sl resp.} $[2,~\infty]$).
A hard constraint for $\tilde{G}_i$ is given by ``the state, which was originally the final state of the top-level TDES, is eventually achieved''.
Soft constraints represents ``states of $\tilde{G}_i$, which were not originally the initial state and the final state, are eventually achieved'' and weights of all soft constraints are 1.

We consider the computational time and the sum of weights of satisfied soft constraints.
In the hierarchical planning, ``the computational time'' represents the time that it takes to compute executions of all TDESs for all $\kappa\in K$ and $\lambda\in \Lambda$, and ``satisfied soft constraints'' means soft constraints satisfied by one of candidates determined by the upper-level plans.
Note that, in this comparison, the results of execution which it takes more than one hour to compute are invalid.
Let $K=\{1,~0.5,~0.01\}$, $\Lambda=\{(1.0,~0),~(0.33,~0.33),~(0.1,~0.1)\}$, and $\mu=0.1$. 
Then, the results are shown in Table \ref{tab:comp}.
\begin{table}[h]
\caption{* in column denotes the invalid results.}\label{tab:comp}
\centering
\begin{tabular}{c||c|c|c|c}
&\multicolumn{2}{c|}{Time [sec]}  &\multicolumn{2}{c}{Sum of weights} \\\cline{2-5}
&Hierarchical TDES& TDES&Hierarchical TDES& TDES \\
\hline
$\mathcal{G}_1,~\tilde{G}_1$&25.0   & 36.9 &  6(all) &  5\\
$\mathcal{G}_2,~\tilde{G}_2$& 91.9  &  135.3&  8(all)  & 6\\
$\mathcal{G}_3,~\tilde{G}_3$& 105.9  & * &  6(all-6)  &* \\
$\mathcal{G}_4,~\tilde{G}_4$& 177.1  & * &  8(all-6)  & *\\
\end{tabular}
\end{table}
%
%
%
\end{comment}
%
\red{\section{Complexity(kari)}}
%
%
%
\section{Conclusion}
%

In this paper, we considered two approaches to a planning problem for a real-time system where a specification is given by an LTL$_f$ formula.
One is to relax the specification by partitioning the specification into a hard constraint and a set of pairs of a  soft constraint and its weight. 
Then, we formulated the problem with these constraints as an ILP problem.
The other approach is hierarchical planning that allows to reduce the computational costs.
For this approach, we proposed a HTDES and we especially considered a two-level HTDES that is composed of one upper level TDES and several lower level TDESs with different time-scales.
Each lower level TDES describes detailed behaviors in the corresponding state in the upper level TDES.
We proposed an algorithm of hierarchical planning where a rough plan is determined by using the upper level TDES and detailed plans are determined by using lower level TDESs.
%
It is future work to apply the proposed approaches to control of multi-agent systems.
%
%
%
%
\begin{thebibliography}{99}

\bibitem{CL2008}%
C.~G.~Cassandras and S.~Lafortune.
\newblock {\em Introduction to Discrete Event Systems}.
\newblock Springer, 2009.

\bibitem{CSX2018}%
J.~Campos, C.~Seatzu, and X.~Xie.
\newblock {\em Formal Methods in Manufacturing}.
\newblock CRC press, 2014.

\bibitem{SSS2013}%
C.~Seatzu, M.~Silva, and J.~H.~van Schuppen.
\newblock \emph{Control of Discrete Event Systems. Automata and Petri Net Perspective, Letcure Notes in Control and Information Science}. vol.~433,
\newblock Springer, 2013.

\bibitem{ghallab2016automated}
M.~Ghallab, D.~Nau, and P.~Traverso.
\newblock {\em Automated Planning and Acting}.
\newblock Cambridge University Press, 2016.

\bibitem{ramadge1987supervisory}%
P.~J.~Ramadge, and W.~M.~Wonham.
\newblock Supervisory control of a class of discrete event processes.
\newblock {\em SIAM Journal on Control and Optimization}, vol.~25, no.~1, pages 206--230, 1987.

\bibitem{TW1986}%
J.~G.~Thistle and W.~M.~Wonham.
\newblock Control problems in a temporal logic framework.
\newblock {\em International Journal of Control}, vol.~44, no.~4, pages 943--976, 1986.

\bibitem{JK2006}%
S.~Jiang and R.~Kumar.
\newblock Supervisory control of discrete event systems with CTL* temporal logic specifications.
\newblock {\em SIAM Journal on Control and Optimization}, vol.~44, no.~6, pages 2079--2103, 2006.

\bibitem{SU2018}%
A.~Sakakibara and T.~Ushio.
\newblock Decentralized supervision and coordination of concurrent discrete event systems under LTL constraints.
\newblock In \emph{Proceedings 14th Workshop on Discrete Event Systems}, pages 18--23, 2018.

\bibitem{GV1999}%
G.~de. Giacomo and M.~Y.~Vardi.
\newblock Automata-theoretic approach to planning for temporally extended goals.
\newblock In {\em Proceedings of European Conference on Planning}, pages 226--238, Springer, 1999.

\bibitem{BK2008}%
C.~Baier and J.-P.~Katoen.
\newblock {\em Principles of Model Checking}.
\newblock MIT press, 2008.

\bibitem{BHJLS2006}%
A.~Biere, K.~Heljanko, T.~Junttila, T.~Latvala, and V.~Schuppan.
\newblock Linear encodings of bounded LTL model checking.
\newblock \emph{Logical Methods in Computer Science}, vol.~2, no.~5, pages 1--64, 2006.

\bibitem{S2016}%
Y.~Shoukry, P.~Nuzzo, I.~Saha, A.~L.~Sangiovanni-Vincentelli, S.~A.~Seshia, G.~J.~Pappas, and P.~Tabuada.
\newblock Scalable lazy SMT-based motion planning.
\newblock In {\em Proceedings of 55th IEEE Conference on Decision and Control}, pages 6683--6688, 2016.

\bibitem{sahin2019multirobot}%
Y.~E.~Sahin, P.~Nilsson, and N.~Ozay.
\newblock Multirobot coordination with counting temporal logics.
\newblock {\em IEEE Transactions on Robotics}, 2019.

\bibitem{kupferman2001model}%
O.~Kupferman and M.~Y.~Vardi.
\newblock Model checking of safety properties.
\newblock {\em Formal Methods in System Design}, vol.~19, no.~3, pages 291--314, 2001.

\bibitem{cho2017cost}%
K.~Cho, J.~Suh, C.~J.~Tomlin, and S.~Oh.
\newblock Cost-aware path planning under co-safe temporal logic specifications.
\newblock {\em IEEE Robotics and Automation Letters}, vol.~2, no.~4, pages 2308--2315, 2017.

\bibitem{feyzabadi2016multi}%
S.~Feyzabadi and S.~Carpin.
\newblock Multi-objective planning with multiple high level task specifications.
\newblock In {\em Proceedings of the 2016 IEEE International Conference on Robotics and Automation}, pages 5483--5490, 2016.

\bibitem{Zhu2017}%
S.~Zhu, L.~M.~Tabajara, J.~Li, G.~Pu, and M.~Y.~Vardi.
\newblock Symbolic LTL$_f$ synthesis.
\newblock In {\em  Proceedings of the 2017 International Joint Conferences on Artificial Intelligence}, pages 1362--1369, 2017.

\bibitem{li2019sat}%
J.~Li, K.~Y.~Rozier, G.~Pu, Y.~Zhang, and M.~Y.~Vardi.
\newblock Sat-based explicit LTL$_f$ satisfiability checking.
\newblock In {\em Proceedings of the AAAI Conference on Artificial Intelligence}, vol.~33, pages 2946--2953, 2019.

\bibitem{camacho2019strong}%
A.~Camacho and S.~A.~McIlraith.
\newblock Strong fully observable non-deterministic planning with LTL and LTL$_f$ goals.
\newblock In {\em Proceedings of the 2019 International Joint Conferences on Artificial Intelligence}, pages 5523--5531, 2019.

\bibitem{BW1994}%
B.~A.~{Brandin} and W.~M.~{Wonham}.
\newblock Supervisory control of timed discrete-event systems.
\newblock {\em IEEE Transactions on Automatic Control}, vol.~39, no.~2, pages 329--342, 1994.

\bibitem{K1990}%
R.~Koymans.
\newblock Specifying real-time properties with metric temporal logic.
\newblock {\em Real-time systems}, vol.~2, no.~4, pages 255--299, 1990.

\bibitem{BKD1998}
M.~Barveau, F.~Kabanza, and R.~St.~Denis.
\newblock A method for the synthesis of controllers to handle safety, liveness, and real-time constraints.
\newblock {\em IEEE Transactions on Automatic Control}, vol.~43, no.~11, pages 1543--1559, 1998.

\bibitem{DS2014}%
A.~Dhananjayan and K.~T.~Seow.
\newblock A metric temporal logic specification interface for real-time discrete-event control.
\newblock {\em IEEE Transactions on Systems, Man, and Cybernetics: Systems}, vol.~44, no.~9, pages 1204--1215, 2014.

\bibitem{KHU2020}%
T.~Kinugawa, K.~Hashimoto, and T.~Ushio.
\newblock Control of timed discrete event systems with ticked linear temporal logic constraints.
\newblock In {\em Preprint of 21st IFAC World Congress}, 2020.

\bibitem{AKW2008}%
R.~Alur, A.~Kanade, and G.~Weiss.
\newblock Ranking automata and games for prioritized requirements.
\newblock In {\em Proceedings of the 20th International Conference of Computer Aided Verification}, pages 240--253, 2008.

\bibitem{DGT2018}%
R.~Dimitrova, M.~Ghasemi, and U.~Topcu.
\newblock Maximum realizability for linear temporal logic specifications.
\newblock In {\em International Symposium on Automated Technology for Verification and Analysis}, pages 458--475, Springer, 2018.

\bibitem{QC2000}%
M.~H.~de Queiroz and J.~E.~R.~Cury.
\newblock Modular supervisory control of large scale discrete event systems.
\newblock In {\em Discrete Event Systems:  Analysis and Control edited by R.\ Boel and G.\ Stremersch}, pages 103--110, Springer, 2000.

\bibitem{WW1996a}%
K.~C.~Wong and W.~M.~Wonham.
\newblock Hierarchical control of discrete-event systems.
\newblock {\em Discrete Event Dynamic Systems}, vol.~6, no.~3, pages 241--273, 1996.

\bibitem{WW1996b}%
K.~C.~Wong and W.~M.~Wonham.
\newblock Hierarchical control of timed discrete-event systems.
\newblock {\em Discrete Event Dynamic Systems}, vol.~6, no.~3, pages 275--306, 1996.

\bibitem{GAUDIN2004131}
B.~Gaudin and H.~Marchand.
\newblock Supervisory control of product and hierarchical discrete event systems.
\newblock {\em European Journal of Control}, vol.~10, no.~2, pages 131--145, 2004.

\bibitem{Ngo2018}%
Q.~H.~Ngo and K.~T.~Seow.
\newblock A hierarchical consistency framework for real-time supervisory control.
\newblock {\em Discrete Event Dynamic Systems}, vol.~28, no.~3, pages 375--426, 2018.

\bibitem{8759973}%
M.~{Goorden}, J.~van de Mortel-Fronczak, M.~{Reniers}, W.~{Fokkink}, and J.~{Rooda}.
\newblock Structuring multilevel discrete-event systems with dependence structure matrices.
\newblock {\em IEEE Transactions on Automatic Control}, vol.~65, no.~4, pages 1625--1639, 2020.

\bibitem{7497833}%
J.~{Komenda}, T.~{Masopust}, and J.~H.~van~Schuppen.
\newblock Control of an engineering-structured multilevel discrete-event system.
\newblock In {\em Proceedings of the 13th International Workshop on Discrete Event Systems}, pages 103--108, 2016.

\end{thebibliography}

%\begin{IEEEbiography}
\begin{IEEEbiographynophoto}{Takuma Kinugawa}
received his B. E. degree in 2020 from Osaka University. He is currently an M. E. candidate at Graduate School of Engineering Science, Osaka University. His research interests include control of real-time systems using temporal logic.
%\end{IEEEbiography}
\end{IEEEbiographynophoto}
%
%\begin{IEEEbiography}{Toshimitsu Ushio}
\begin{IEEEbiographynophoto}{Toshimitsu Ushio}
received his B. E., M. E., and Ph. D. degrees in 1980, 1982, and 1985, respectively,
from Kobe University.  He joined Osaka University as an Associate Professor in 1994, and is currently a Professor. His research interests include control and analysis of discrete event systems and hybrid systems.  Prof. Ushio is a member of IEEE, SICE, and ISCIE.
\end{IEEEbiographynophoto}
%\end{IEEEbiography}
%
\end{document}