\documentclass[journal,twoside,web]{IEEEtran}
\usepackage{cite}
\usepackage{algorithm}
\usepackage{algorithmicx,algpseudocode}
\usepackage{graphicx}      % include this line if your document contains figures
%\usepackage{natbib}        % required for bibliography
\usepackage{mathtools}
\usepackage{subfigure}
\usepackage{cases}
\usepackage{amsmath}
\usepackage{balance}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{comment}
\usepackage{color}
\usepackage{subfigmat}
\graphicspath{{./pic/}}
\newcommand{\qedwhite}{\hfill \ensuremath{\Box}}
\newtheorem{myrem}{Remark}
\newtheorem{dfn}{Definition}
\newtheorem{pbm}{Problem}
\newtheorem{exa}{Example}
\newcommand{\rdef}[1]{Definition\,\ref{#1}}
\newcommand{\req}[1]{\eqref{#1}} 
\newcommand{\rpbm}[1]{Problem\,\ref{#1}}
\newcommand{\rsec}[1]{Section\,\ref{#1}}
\newcommand{\rfig}[1]{Fig.\,\ref{#1}} 
\renewcommand{\Pr}{\widehat{Pr}}
\newcommand{\Count}{{\sf Count}}
\newcommand{\tick}{{\sf tick}}
\newcommand{\ttick}{{\textit tick}}
\newcommand{\AP}{{\textit AP}}
\newcommand{\ap}{{\textit ap}}

\newcommand{\Len}{{\sf L}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\W}{\mathcal{W}}
\newcommand{\U}[1]{\mathcal{U}_{[#1]}}
\newcommand{\F}[1]{\Diamond_{[#1]}}
\newcommand{\G}[1]{\Box_{[#1]}}

\newcommand{\red}[1]{\textcolor{red}{#1}}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{textcomp}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
%\markboth{\journalname, VOL. XX, NO. XX, XXXX 2017}
%{Author \MakeLowercase{\textit{et al.}}: Preparation of Papers for IEEE TRANSACTIONS and JOURNALS (February 2017)}
%
%
%
\begin{document}
%
\title{Hierarchical Planning under Hard and Soft  Specifications Given by Ticked Linear Temporal Logic}
%
\author{Takuma Kinugawa, Toshimitsu Ushio, \IEEEmembership{Member, IEEE}
\thanks{The authors are with the Graduate School of Engineering Science, Osaka
University, Osaka, Japan (e-mail: kinugawa@hopf.sys.es.osaka-u.ac.jp,\ ushio@sys.es.osaka-u.ac.jp). }
\thanks{This work partially supported by JST ERATO Grant Number JPMJER1603 and JST CREST Grant Number JPMJCR2012.}
\thanks{The authors would like to thank Prof.\ K.\ Hashimoto(Osaka University) for his fruitful comments.}
}
\maketitle

\begin{abstract}
% Abstract of not more than 200 words.
%TDES実行列を求めるのは，実用上困難が多い．なぜなら，時間の制約を含んだ仕様を満たさないことがあるし，DESより大規模なシステムだと求めるのに時間がかかる．
%planner とコントローラーがあっていない
A hard problem for a real-time system is synthesis of a  planner or a controller that satisfies the given specification since a model of the system and the specification include temporal constraints.
%この論文では，それらに対するapproachesを提案します．
In this paper, to attack this problem, we propose two approaches to determine a plan for a real-time system modeled by a timed discrete event system (TDES), where a control specification is given by a ticked LTL$_f$ formula whose semantics is defined over a finite state sequence including a special event \textit{tick} that means the elapse of one time unit.
%一つ目は定量的な解を求める方法を提案します．
One approach is to relax the specification by partitioning the specification into \textit{hard constraints} and \textit{soft constraints}.
We give a preference, called \textit{weight}, to each soft constraint and find an execution of the TDES that satisfies all hard constraints and some soft constraints whose combination is prefer to any other one. 
%二つ目は階層型TDESの制御方法
Another approach is to represent a large-scale system by several subsystems, introducing a novel hierarchical model called hierarchical TDES.
Some states in the upper level TDES are refined by the lower level TDESs and time-scales of the upper level TDES and the lower level TDES can be different.
In the hierarchical TDES, rough plans are determined in the upper level TDESs, then detailed plans are determined in the lower level TDESs.
%
The effectiveness of each approach is illustrated through an example of a path planning problem of a mobile robot.
%
\end{abstract}

\begin{IEEEkeywords}
Linear temporal logic, path planning, timed discrete event system.
\end{IEEEkeywords}
%
\section{Introduction}
%
%
%
A discrete event system(DES) is useful for the design of a logical high-level controller in many engineering fields such as manufacturing systems, traffic systems, and robotics\cite{CL2008,CSX2018,SSS2013}.
%
For example, a planning problem is an important application of control of DESs \cite{ghallab2016automated}.  Both a considered system and its specification are modeled by a formal manner and the synthesis of a planner is formulated as a control problem.  
Ramadge and Wonham \cite{ramadge1987supervisory} considered a logical control problem called a supervisory control problem, where a specification is given by a formal language, and proposed an algorithm for synthesis of a supervisor.
%
%
However, in practice, it is difficult to determine formal languages that accurately describe desired behaviors of the DES.
So, a temporal logic(TL) formula has been used as a formal description of a control specification in the DES\cite{TW1986,JK2006,SU2018}.

%
Many different TLs have been proposed and their expressivenesses have been studied. 
Among them, the linear temporal logic(LTL) is often used because it can describe many properties such as safety, stability, and progress.
There are mainly two approaches to translate LTL formulas for use.
A basic approach is to translate an LTL formula into an automaton \cite{GV1999}. This approach is widely used for model checking \cite{BK2008}.
Another approach is to translate an LTL formula into its linear encodings \cite{BHJLS2006}. This approach is often used for bounded model checking using a satisfiability (SAT)-solver. 
Moreover, Soukry et al.\cite{S2016} provided an approach of motion planning with LTL specifications which are translated into linear encodings.
%
However, it is a drawback of LTL to need double-exponential time at worst to translate an LTL formula into an automaton.
The cyclic (loop) constraint is needed when we use linear encodings translated from an LTL formula\cite{sahin2019multirobot}. 
Kupferman and Vardi \cite{kupferman2001model} introduced the fragment of LTL, called safe/co-safe LTL. 
This fragment can be interpreted over a bad/good prefix of an infinite execution.
A syntactically co-safe LTL, that is a fragment of safe/co-safe LTL, is often used to give a specification for a planning problem \cite{cho2017cost,feyzabadi2016multi}.
%
However, every fragment of safe/co-safe LTL is restricted in its syntax, so that its expressiveness is poorer than one of LTL.  
To maintain rich expressiveness of LTL, LTL over finite execution, named LTL$_f$, was proposed and synthesis methods based on LTL$_f$ formulas have been studied recently\cite{Zhu2017,li2019sat}.
LTL$_f$ is defined over a finite execution with expressiveness of LTL.
Because of these good properties of LTL$_f$, LTL$_f$ formulas are recently used as specifications for planning problems\cite{camacho2019strong}.

On the other hand, when real-time systems are modeled, we also need to take temporal constraints for the systems into consideration.
For this reason, to represent temporal information of the real-time systems and real-time constraints in their DES models, Brandin et al.\cite{BW1994} formulated timed discrete event systems (TDESs) by a timed transition graph that is a transition graph with state transitions by the event \textit{tick}.
The occurrence of \textit{tick} represents that one unit time has elapsed.
In verification and control of TDESs, control specifications depend not only on logical constraints but also on the timing at which each event occurs. 
Koymans\cite{K1990} proposed TL, called metric TL(MTL),  for an infinite timed state sequence with a function that assigns the time stamp to each state.
The MTL formulas have been used as control specifications for TDESs.
Barbeau et al.\cite{BKD1998} dealt with a synthesis problem of controllers for TDESs with a control specification described by an MTL formula. 
Dhananjayan et al.\cite{DS2014} proposed an MTL specification interface that translates an MTL specification to a finite timed transition graph used in the synthesis of a timed supervisor.

%
In the previous works, the specifications are described by MTL formulas over infinite sequences of the TDESs. 
However, specifications for a planning problem are often given for a finite sequence\cite{camacho2019strong}. 
%
We provided a novel approach of a controller synthesis problem for TDESs, introducing a novel LTL called \textit{ticked LTL}$_f$\cite{KHU2020}.
As with the standard LTL$_f$\cite{Zhu2017}, the formula is interpreted over the finite execution.
In contrast to the standard LTL$_f$, the formula is given as an MTL, where temporal properties are described by counting the number of the event \textit{tick} in the execution of the TDES.
We presented a linear encoding scheme such that the problem can be translated into an integer linear programming (ILP) problem. 
Then, we solve a feasible solution of the ILP problem, so that we have a finite execution of the TDES satisfying the ticked LTL$_f$ specification.
However, there are the following two issues in \cite{KHU2020}.
\begin{itemize}
\setlength{\itemindent}{0.5cm}
\item[(P1)]
%Conflicts among specifications.
In some cases, we have no execution that satisfies a given specification though there may exist executions that satisfy a part of the given specification.
%
\item[(P2)]
%Difficulty to find an execution of a TDES modeling complex behavior
It is computationally difficult to find a finite execution in a long time horizon of a large-scale TDES satisfying many requirements. 
\end{itemize}
%
%
Related works for the above issues are summarized as follows.

%
For (P1), a specification is decomposed into a set of subspecifications and several approaches to the synthesis of a controller that satisfies as many subspecifications as possible have been proposed. 
Alur et al.\cite{AKW2008} presented an automaton-based algorithm.
For each subspecification with a priority and an automaton corresponding with a rank based on its priority is given. 
%
Then, the ``best'' selection of subspecifications are computed.
%
Dimitrova et al.\cite{DGT2018} proposed a method to formulate a weighted partial MaxSAT problem with quantitative specifications described by LTL formulas.
A weighted partial MaxSAT problem has mandatory constraints, called hard constraints, and optional constraints, called soft constraints, and there is a $weight$ for each soft constraint. 
This weight is used as a reward.
Then, the objective of a weighted partial MaxSAT problem is to find the assignment that satisfies all hard constraints and some soft constraints that maximize the sum of the weights.

%
For (P2), two approaches have been studied.
One approach is to model a complex system as the composition of simpler subsystems.
Queiroz and Cury\cite{QC2000} modeled a large-scale system by the composition of some smaller subsystems and a control specification is given for each subsystem.
%
Another approach is to leverage a model with a hierarchical structure.
%
Wong and Wonham\cite{WW1996a,WW1996b} introduced a hierarchical structure by abstracting the original systems using a bottom-up approach.
Gaudin and Marchand\cite{GAUDIN2004131} proposed the methods to model a system with a hierarchical structure using top-down approach and control this hierarchical model.
%
Ngo and Seow\cite{Ngo2018} proposed a control method for a hierarchical model with timing property.
%
Additionally, in \cite{8759973,7497833}, a multilevel DES composed of a finite number of levels was proposed. At each level, there are one or more groups of subsystems modeled by DESs. 
Each subsystem at each level except the lowest level can have one or more subsystems at the next-lower level.

%
%
In this paper, we propose methods to resolve both (P1) and (P2).
For (P1), we translate the ticked LTL$_f$ formula into its linear encodings based on \cite{DGT2018}. We partition a specification described by ticked LTL$_f$ formulas into a mandatory one corresponding to a hard constraint, and some optional ones corresponding to soft constraints.
%
Then, we assign a weight to each soft constraint corresponding to its preference and apply the MaxSAT to determines a set of satisfied soft constraints. 
For (P2), we introduce a hierarchical TDES where some states of the upper level TDES are refined by TDESs.
%
This structure is similar to \cite{GAUDIN2004131,8759973}.
However, we introduce different time-scales in the upper level and the lower level TDESs so that rough control actions in long time horizon are determined using the upper level TDES while detailed ones in short time horizon are determined using the lower level TDESs. 

%
%8
%
The rest of this paper is organized as follows.
In Section 2, we introduce the definition of TDES formulated by Brandin and Wonham\cite{BW1994}.
In Section 3, we review the definition of ticked LTL$_f$.
In Section 4, to deal with (P1), we partition a specification given by an LTL$_f$ formula into a hard constraint and several soft constraints with weights, and formulate a planning problem as a weighted partial MaxSAT problem.
We show an example where we can not find an execution of the TDES in \cite{KHU2020}.
In Section 5, we define a hierarchical TDES.
In Section 6, we present a method to give a specification for each higher level TDES and lower level TDES and to find its execution satisfying the given specification.
In Section 7, we apply the proposed method to a path planning problem of a mobile robot. 
Section 8 provides a summary of the paper and future research directions.
%
%
\section{Timed discrete event system}\label{tdes}
%
In this section, we review a timed discrete event system proposed by Brandin and Wonham\cite{BW1994}, where temporal information is modeled by a special event {\sl tick}. First, let us define an untimed discrete event system (DES) by a transition system.
%
\begin{dfn}[Untimed DES] \label{def:G_act}
An untimed DES is a tuple $G_{act}=(S_{act}, \Sigma_{act}, \delta_{act}, s_{0,act}, L_{act}, A_{act})$ where $S_{act}$ is a set of states, $\Sigma_{act}$ is a set of events, $\delta_{act} : S_{act} \times \Sigma_{act} \rightarrow S_{act}$ is a transition function, $s_{0,act}$ is the initial state, $AP_{act}$ is a set of atomic propositions and $L_{act} : S_{act} \rightarrow 2^{AP_{act}}$ is a labeling function. \qedwhite
\end{dfn}

Next, we incorporate some \textit{timing} properties in $G_{act}$. 
We introduce $l_{\sigma} \in \mathbb{N}$, $u_{\sigma} \in  \mathbb{N} \cup \{\infty\}$ with  $l_{\sigma} \leq u_{\sigma}$ which are called the lower time and the upper time bound, respectively.
Additionally, for integers $m$ and $n$ with $m \leq n$, $[m,\ n]$ denotes a set of integers between $m$ and $n$, that is, $[m,\ n]=\{ m, m+1, \ldots , n\}$.
Then, we assume that each event $\sigma \in \Sigma_{act}$ is enabled during a specified timer interval $[ l_{\sigma},\ u_{\sigma}]$.
%
In particular, the event $\sigma$ is called a prospective ({\sl resp.} remote) event if $u_{\sigma} \in \mathbb{N}$ ({\sl resp.} $u_{\sigma} = \infty$). 
Let $\Sigma_{spe}$ and $\Sigma_{rem}$ $\subseteq \Sigma_{act}$ be the sets of prospective and remote events, respectively.  Note that $\Sigma_{spe} \cup \Sigma_{rem} = \Sigma_{act}$.
Then, we introduce the following timer interval $T_{\sigma}$ for each event $\sigma \in \Sigma_{act}$.
\begin{equation}
\label{T_sigma}
T_{\sigma}= \left\{
\begin{array}{ll}  
\ [ 0,\ u_{\sigma} ]  & \mbox{if } \sigma \in \Sigma_{spe}, \\
\ [ 0,\ l_{\sigma} ] & \mbox{if } \sigma \in \Sigma_{rem}. \\
\end{array} \right.
\end{equation}	 
%
We introduce a special event \textit{tick}, which represents the global clock and will be utilized as an additional event to $\Sigma_{act}$. 
Based on the above definition, a timed DES corresponding to $G_{act}$ is defined as follows: 

\begin{dfn}[Timed DES]\label{def:G}
A timed DES (TDES) corresponding to $G_{act}$ is a tuple $G=(S, \Sigma, \delta, s_0,AP, L)$ where $S = S_{act} \times \prod_{\sigma\in \Sigma_{act}} T_{\sigma}$ is a set of states, $\Sigma= \Sigma_{act} \bigcup \{\textit{tick}\}$ is a set of events, $s_0 \in S$ is the initial state where $s_0 = (s_{0,act}, \{ t_{\sigma,0} | \sigma \in \Sigma_{act} \})$ and $t_{\sigma,0}$ is given by
					\begin{equation}
						t_{\sigma, 0} \coloneqq \left\{
						\begin{array}{ll}  
							\ u_{\sigma}  & \mbox{if } {\sigma} \in \Sigma_{spe}, \\
							\ l_{\sigma} & \mbox{if } {\sigma } \in \Sigma_{rem}, \\
						\end{array} \right.
					\end{equation}	
$AP = AP_{act} $ is a set of  atomic propositions and $L  : S \rightarrow 2^{AP} $ is a labeling function, where $L(s)=L_{act}(a)$ and $s = (a, \{ t_\sigma | \sigma \in \Sigma_{act} \}) \in S$. \qedwhite \end{dfn}
%
The concrete definition of the transition function $\delta$ is omitted in this paper and the reader is referred to \cite{BW1994} for details.
%
%
%
%
A \textit{finite execution $\pi$ of} $G$ is a finite sequence of alternating states and events
\begin{align}\label{execution}
\pi = s(0)e(1)s(1)\ldots e(\Len) s(\Len), 
\end{align}
where $\Len \in \mathbb{N}_{> 0}$, 
$s(k) \in S$ with $s(0) = s_0$, $\forall k\in[0,\ \Len]$, $e(k') \in \Sigma$, $\forall k' \in [1,\ \Len]$ and $(s({l-1}), e({l}), s(l)) \in \delta$, $\forall l\in [1,\ \Len]$. 
Here, $\Len$ is called the \textit{length} of $\pi$.
Moreover, the corresponding sequence of states 
\begin{align}
s(0) s(1) \ldots, s(\Len) \notag
\end{align}
is called a \textit{trajectory} of $G$. 
For given \req{execution} and $k\in[0,\ \Len]$, let $\pi(k) = s(k)$, and 
\begin{align}
\pi(k...) = s(k) e({k+1}) s({k+1}) \ldots e({\Len}) s({\Len}), \notag 
\end{align}
i.e., $\pi(k...)$ denotes the $k$-th suffix of $\pi$. Moreover, for given $k, j\in[0,\ \Len]$ with $k\leq j$, let $\pi(k...j)$ be the partial suffix given by 
\begin{align}
\pi(k...j) = s(k) e({k+1}) s({k+1}) \ldots e({j}) s({j}). \notag 
\end{align}
Moreover, for given \req{execution} and $k, j\in [0,\ \Len]$ with $k \leq j \leq \Len$, let $count_\pi(k,j)$ denote the number of the event \textit{tick} included in $\pi(k...j)$.
\red{Note that it takes $count_{\pi}(0, {\Len})+1$ unit times to complete the execution $\pi$ and we call this time \textit{the time for $\pi$}.}
%
For example, if $\pi=a,\textit{tick},a,\sigma,b,\textit{tick},a$ with $S=\{a,b\}$ and $\Sigma = \{\sigma\}\cup \{\textit{tick}\}$, we have $count_\pi(0,3) = 2$, $count_\pi (1, 3) = 1$ since $\pi(0...3) = a,\textit{tick},a,\sigma,b,\textit{tick},a$ and $\pi(1...3) = a,\sigma,b,\textit{tick},a$. Note that we have $count_\pi(k, k)=0$, $\forall k \in [ 0, \ \Len ]$, since $\pi(k...k) = s(k)$ and so no events occur in $\pi(k...k)$.
%
%

To focus on states in $S_{act}$, a function $\Pr: S \cup \Sigma \to S_{act} \cup \Sigma $ for $G$ is defined as follows.
\label{def:Pr}
\[
\Pr (x )=\left\{
\begin{array}{ll}
s_{act} & \mbox{if }x =(s_{act}, (t_{\sigma})) \in S,  \\ 
x  & \mbox{if } x \in \Sigma , 
\end{array} \right.
\]
where $x  \in S  \cup \Sigma $. 
$\Pr : S \cup \Sigma \to S_{act} \cup \Sigma$ is extended to $\Pr : (S  \cup \Sigma )^* \to  (S_{act} \cup \Sigma )^*$ in the usual way.
%
%
\section{ticked linear temporal logic}
We now introduce a fragment of linear temporal logic called ticked LTL$_f$ over a TDES\cite{KHU2020}.
As will be seen below, this formula is interpreted over a finite execution \req{execution}, and provides an extension of the LTL$_f$ formulas\cite{Zhu2017} in the sense that we incorporate some timing properties via the event ${\textit{tick}}$\footnote{By the similar way, we can define ticked LTL, but we consider ticked LTL$_{f}$ in this paper since we deal with planning over a finite length.}.
First, we define its syntax as follows.

\begin{dfn}[Syntax of ticked LTL$_f$]\label{dfn:syntax}
A ticked LTL$_f$ formula over a finite sequence of sets of atomic propositions is recursively defined according to the following grammar: 
\begin{align}
\phi \coloneqq True \ |\ ap\ |\ \lnot \phi\ |\ \phi_1\land \phi_2\ |\ \phi_1U_{[m,n]} \phi_2 ,\notag
\end{align}
where $ap \in AP$, $m$ and $n$ are nonnegative integers with $m\leq n$. \qedwhite
\end{dfn}
%
Additionally, we use the following boolean operators.
\begin{align}
\phi_1 \lor \phi_2 &\coloneqq \lnot(\lnot \phi_1 \land \lnot \phi_2), \notag\\ 
\phi_1 \rightarrow \phi_2 & \coloneqq \lnot \phi_1 \lor \phi_2, \notag\\ 
\phi_1 \leftrightarrow \phi_2 &\coloneqq (\phi_1 \rightarrow \phi_2)\land(\phi_2 \rightarrow \phi_1). \notag
\end{align} 
Moreover, other temporal operators, such as $\Diamond_{[m,n]}$ (future) and $\Box_{[m,n]}$ (globally) are defined by
\begin{align}\label{futureglobal}
\Diamond_{[m,n]} \phi \coloneqq True U_{[m,n]} \phi, \ \Box_{[m,n]} \phi \coloneqq \lnot \Diamond_{[m,n]} \lnot \phi. 
\end{align}
%
Its semantics is defined over a finite execution in \req{execution} and is formally given as follows. 
\begin{dfn}[Semantics of ticked LTL$_f$]
Given a finite execution $\pi = s(0) e(1)$$s(1) \ldots e(\Len) s(\Len)$, the satisfaction of the ticked LTL$_f$ formula $\phi$ for the $k$-th suffix of $\pi$ $(k\in [0,\ \Len])$, denoted as $\pi (k...) \models \phi$, is defined recursively as follows.
\begin{itemize}
\item 	$\pi(k...) \models True$,
\item 	$\pi(k...) \models ap$ if and only if $ap \in L(\pi(k))$,
\item 	$\pi(k...) \models \lnot \phi$ if and only if $\pi(k...) \not\models \phi$,
\item 	$\pi(k...) \models \phi_1\land \phi_2$ if and only if $\pi(k...) \models \phi_1 \land \pi(k...)\models \phi_2$,
\item 	$\pi(k...) \models \phi_1U_{[m,n]} \phi_2$ if and only if there exists $j \in [k ,\ \Len]$ such that $m \leq count_\pi(k, j) \leq n$, $\pi(j...) \models \phi_2$ and $\pi(i...) \models \phi_1$, $\forall i \in [k,j-1]$. \qedwhite
	\end{itemize}
	\end{dfn}

Intuitively, the formula $\phi_1 U_{[m,n]}  \phi_2$ indicates that $\phi_1$ holds true until $\phi_2$ holds true during the interval such that the number of ticked events is between $m$ and $n$. 
Note that we do not include the operator $\bigcirc$ (next) in the syntax, which will not be utilized to express the specification in this paper. In prospective of tick, $F_{[1,1]}$ can be used as $\bigcirc$. 
We denote by $\pi \models \phi$ if and only if $\pi (0...) \models \phi$.

\begin{exa}
Consider the following finite execution.
\begin{align}
\pi=a,\textit{tick},a,\sigma,b,\textit{tick},a \notag
\end{align}
and a ticked LTL$_f$ formula $\phi=ap_1 U_{[1,3]} ap_2$ with $AP=\{ap_1,ap_2\}$, $S=\{a,b\}$, $\Sigma=\{\sigma\}\cup\{\textit{tick}\}$ and $L(a)=\{ap_1\},\ L(b)=\{ap_2\}$. Then, $\pi(0...) (= a,\textit{tick},a,\sigma,b,\textit{tick},a)$ satisfies $\phi$, since $a$ holds true until $b$ holds true while the number of \textit{tick} counted from $\pi(0)$ is $1$, i.e., $count_{\pi}(0, 2) = 1 \in[ 1,\ 3]$. However, $\pi (1...) (= a,\sigma,b,\textit{tick},a)$ does \textit{not} satisfy $\phi$, since $b$ holds true while the number of \textit{tick} counted from $\pi(1)$ is $0$, i.e., $count_{\pi}(1, 2) = 0 \notin [1, 3]$. \qedwhite 
\end{exa}

%
%
\section{Planning under ticked LTL$_f$ constraints}\label{sec4}
%
We consider a planning problem for a system modeled by a TDES $G$.
A specification for this plan is given by a ticked LTL$_f$ formula introduced in the previous section. 
In general, however, no execution satisfying the specification may exist though we find an execution that partially satisfies it. 
One approach to relax the specification is to partition the formula into a mandatory subformula called a hard constraint and several optional subformulas called soft constraints, where the former is the indispensable requirement and the latter describes a requirement preferable to be satisfied.  
Some specifications for the plan are represented as soft constraints.  
We assign to each soft constraint a weight that indicates the preference for its satisfaction and propose a method for finding a solution.

%
\red{
\subsection{Problem formulation}\label{sec:pbm}
}
%
We assume that there are one hard constraint $\phi$ and $N$ soft constraints $\psi_1,...,\psi_N$. 
When we introduce soft constraints to a planning problem, we consider the following points.
\begin{itemize}
\item
There are combinations of satisfaction of soft constraints.
\item
There is a trade-off between the shortness of the time for the result of(resulting) execution and the sum of weights of the soft constraints satisfied by the execution.
\end{itemize}

For the first point, we consider the case where a preference on the satisfiability of soft constraints exists.
To explain the preference of the satisfactions of the soft constraints, we introduce a positive constant called $weight$ for each soft constraint.
For each soft constraint $\psi_n (n \in [1,N])$, its weight is denoted by $weight_n$. The larger sum of weights of satisfied soft constraints is preferred.
We denote a set of pairs of a soft constraint and its weight by $\Psi=\{(\psi_n,w_n)|~n\in[1,~N]\}$.

For the second point, 
the combination of satisfaction of soft constraints is changed if we change the ratio of the importance of the time for the result of execution to that(=the importance) of the sum of weights of the satisfied soft constraints.
For example, if the time for the result of execution is important, many soft constraints may not be satisfied. 
On the other hand, if we focus on the sum of weights of the satisfied soft constraints, many soft constraints can be satisfied, while it will take more time.
Let $\kappa(0\leq\kappa\leq1)$ be the ratio of the importance of the time for the result of execution to the sum of weights of the satisfied soft constraints.
Then, we set an objective function 
%$J_\kappa(z_e(0),\ldots z_e(\Len),z_{\psi_1},\ldots,z_{\psi_N})$
$J_\kappa$
to represent these two points and we formulate the problem where the specification is given by a hard constraint and several soft constraints to find an optimal execution of the TDES as follows.
%
\begin{pbm}\label{pbm2}
Given a TDES $G$, a hard constraint given by a ticked LTL$_f$ formula $\phi$, $N$ soft constraints given by ticked LTL$_f$ formulas $\psi_{n}$ and their weights $w_n$ for $n\in[1,\ N]$, the length $\Len>0$, and the objective function $J_\kappa$,
find a finite execution $\pi$ of $G$ such that
\begin{eqnarray}
&\mbox{max: }&J_\kappa \notag \\
&\mbox{subject to: }&\pi \models \phi\mbox{, and transition lows of }G\notag
\end{eqnarray}
\qedwhite
\end{pbm}
%
If there is no solution of the ILP problem, i.e., we can not find an execution of $G$ under constraints $\phi$, we denote $\pi=\bot$.
%
To solve \rpbm{pbm2}, we use the following linear encoding schema presented in \cite{KHU2020}.
%
\subsection{Encoding of constraints}\label{encode}
%
We translate a finite trajectory of the TDES $G$, the counting function $count_\pi$, and the ticked LTL$_f$ formula $\phi$ into a set of inequality and equality constraints that can be solved by an integer linear programming (ILP) problem.
The method to translate the ticked LTL$_f$ formula is proposed by extending the method proposed by \cite{BHJLS2006}. Details for the encodings are described below. 
%
\subsubsection{Trajectory of $G$}
To encode the trajectory of $G$, we denote by $A \in \{0, 1\}^{N \times N}$ with $N=|S|$ the \textit{adjacency matrix} of the graph in accordance with $G$, i.e., letting $S = \{s_1, ..., s_{N}\}$, we have $A_{i,{j_i}} = 1$ (the $(i,{j_i})$-component of $A$ is $1$) if and only if there exists $\sigma \in \Sigma$ such that $s_j \in \delta(s_i, \sigma)$, and $0$ otherwise. Moreover, we introduce $\Len+1$ binary vectors $w (k) \in \{0, 1\}^{N}$, $k\in [0,\ \Len]$ to represent the state of $G$ at $k$, where, for each $k \in [0,\ \Len]$, the vector $w(k)$ includes only one non-zero component. That is, if $\pi$ is given by \req{execution}, we have $w_i (k) = 1$ (the $i$-th component of $w(k)$ is $1$) if and only if $s(k) = s_i$, and $0$ otherwise. The trajectory of the states can be then encoded as follows: 
\begin{equation}\label{w}
w(k+1) \leq A^\mathsf{T} w(k), \ {1}^\mathsf{T} _N w(k) =1, 
\end{equation}
where ${1}_N$ is the $N$-dimensional vector whose all elements are 1.
%
%
\subsubsection{Counting function}
Let $c (k, j) \in \mathbb{N}$ for $k, j \in [0,\ \Len]$ with $k\leq j$ be integer variables that represent the number of \textit{tick} events in
%
%
$\pi(k...j)$, i.e., $c(k,j) = m$ if and only if $count_\pi(k,j) = m$. The $c(k,j)$ represents an ILP problem constraint as follows. First, we introduce $\Len$ binary variables $z_e (k) \in \{0, 1\}$, for $k\in[1,\ \Len]$ in order to represent the occurrence of \textit{tick} in the sequence of events, i.e., if $\pi$ is given by \req{execution}, we have $z_e(k) = 1$ if and only if $e(k) = \textit{tick}$. Using $z_e (k)$, $k \in [0,\ \Len]$, $c(k, j)$ is then given by
\begin{align}\label{ckj}
c (k, j) =   \sum^j _{i = k+1} z_e (i),
\end{align}
for $k, j \in [0,\ \Len]$ with $k < j$, and $c (k, k) = 0$, $\forall k\in[0,\  \Len]$. 
The variables $z_e(k)$, $k\in[1,\ \Len]$ encodes whether $e(k)$ is the event \textit{tick} or not. First, let $\alpha \in \{0, 1\}^{N}$ be a binary vector such that $\alpha_i = 1$ (the $i$-th component of $\alpha$ is $1$) if and only if $\delta (s_i, \textit{tick}) !$ (i.e., the event \textit{tick} occurs at $s_i$). Moreover, let $\beta \in \{0, 1\}^{N}$ be a binary vector such that $\beta_i = 1$ (the $i$-th element of $\beta$ is $1$) if and only if there exists $s_{j} \in S$ such that $s_i = \delta (s_{j}, \textit{tick})$ (i.e., there exists a state that can transit to $s_i$ by the occurrence of the event \textit{tick}).

Then, $z_e(k)=1$ if and only if
\begin{align}%\label{count_constraint}
\alpha^\mathsf{T} w (k-1) = 1 \wedge \beta^\mathsf{T} w (k) =1. \notag 
\end{align}
Thus, $z_e(k)=1$ if and only if the following equations hold.
\begin{align}
z_e (k) &\leq \alpha^\mathsf{T} w (k-1),\label{zek1} \\
z_e (k) &\leq \beta^\mathsf{T} w (k), \label{zek2}  \\
z_e (k) & \geq -1 + \alpha^\mathsf{T} w (k-1) + \beta^\mathsf{T} w (k).\label{zek3}
\end{align}
%
\subsubsection{Ticked LTL$_f$ formula}\label{encLTL}
%   
We introduce $\Len+1$ binary variables $z_{\phi}(k) \in \{0,1\}$ for $k \in [0,\ \Len]$ such that $z_{\phi}(k)=1$ if and only if $\pi (k...)$ satisfies $\phi$.
We represent $\textit{ILP}(\phi)$ as the constraints of an ILP problem for the ticked LTL$_f$ formula $\phi$.
The encodings corresponding to the specification $\phi$ can be recursively given as follows.
%
%

\textit{Atomic proposition:} Let $\phi = ap \in AP$ and $v \in \{0, 1\}^N$ be a binary vector such that $v_i = 1$ (the $i$-th component of $v$ is $1$) if and only if $ap \in L(s_i)$. Then, the satisfaction of the formula $\phi$ is encoded as follows: 
\begin{align}
v^\mathsf{T} w(k) &\geq z_\phi (k),\notag\\
v^\mathsf{T} w(k) &< z_\phi (k)+1. \notag
\end{align}

\textit{Negation:} Let $\phi = \neg \psi$. Then, the satisfaction of $\phi$ is encoded as 
\begin{align}\notag
z_\phi (k) = 1 - z_\psi (k). 
\end{align}

\textit{Conjunction:} Let $\phi = \bigwedge^{\Len} _{\ell=1} \psi_\ell$. Then, 
\begin{align}
\label{translate_con}
z_\phi (k) &\leq z_{\psi_\ell} (k),\ \forall \ell \in [1,\ \Len], \notag \\ 
z_\phi (k) & \geq 1-\Len + \sum_{\ell=1}^{\Len} z_{\psi_\ell} (k). \notag
\end{align}

\textit{Disjunction:} Let $\phi = \bigvee^{\Len} _{\ell=1} \psi_\ell$. 
Then, 
\begin{align}
z_\phi (k) &\geq z_{\psi_\ell} (k),\ \forall \ell \in [1,\ \Len], \notag \\ 
z_\phi (k) & \leq \sum_{\ell=1}^{\Len} z_{\psi_\ell} (k). \notag
\end{align}
%%%
With a slight abuse of notation, Boolean operators are used for binary variables. For example, when we consider $\phi = \bigwedge^\Len _{\ell=1} \psi_\ell$, we write $z_\phi = \bigwedge^{\Len} _{\ell=1} z_{\psi_\ell}$. % instead of \req{translate_con}. 
Then, we describe the translation of the temporal operator \textit{until} with this notation.
%%%

\textit{Until:} 
Let $\phi = \psi_1 U_{[m,n]} \psi_2$. We introduce binary variables $\underline{z}_m (k, j), \overline{z}_n (k, j) \in \{0, 1\}$, for $k, j \in [0,\ \Len]$ with $k\leq j$,
such that $\underline{z}_m (k,j) = 1$ ({\sl resp.} $\overline{z}_n (k, j) = 1$) if and only if $m \leq c (k, j)$ ({\sl resp.} $c(k,j) \leq n$). That is, $c(k, j)$ is encoded as 
\begin{eqnarray}
m - M_c &\leq c (k, j) - M_c \underline{z}_m(k,j) &\leq m - \epsilon, \notag\\ 
\red{(n-1)} + \epsilon  &\leq  c (k, j) + M_c \overline{z}_n(k,j) &\leq \red{(n-1)}+M_c, \notag
\end{eqnarray}
where $M_c$ is a sufficiently large number satisfying $M_c >n$ \red{and $\epsilon$ is a sufficiently small number satisfying $\epsilon<1$.} 
Then, the satisfaction of $\phi$ is encoded as 
\begin{align}%\label{until1}
z_\phi (k) = \bigvee^{\Len} _{j=k} z_\phi (k, j),
\end{align}
where 
\begin{align}%\label{until2}
z_\phi (k, j) = \overline{z}_n (k,j) \wedge  \underline{z}_m (k,j) \wedge z_{\psi_2} (j) \wedge \left(\bigwedge^{j-1} _{\ell=k} z_{\psi_1} (\ell) \right).  \notag 
\end{align}

The encodings for $\Diamond_{[m,n]}$ and $\Box_{[m,n]}$are similarly done from  \req{futureglobal} and are thus omitted. 
%
%
\red{\subsection{Optimization problem}}
%
To represent two points in \rsec{sec:pbm}, we introduce(set) the following objective function. 
\begin{align}\label{j1}
J_\kappa= 
-\kappa\sum_{k=1}^{\Len}z_e(k) + (1-\kappa)\sum_{i=1}^{N} w_{i}\cdot z_{\psi_{i}(0)}, 
\end{align}
Then, we convert \rpbm{pbm2} into the following ILP problem by using the encodings considered in Section \ref{encode}. 
%Then, we find an execution that satisfies the hard constraint and some soft constraints such that the sum of weights of the satisfied soft constraints is maximized with the considering the shortness of time. 
%
%Then, based on the above setting about soft constraints and their weights, 
%
%
\begin{eqnarray}
&\mbox{max: }&J_\kappa \notag \\
&\mbox{subject to: }&\req{w}-\req{ckj},\ \textit{ILP}(\phi),\ \textit{ILP}(\psi_i),\notag\\
&&z_{\phi} (0) = 1, {\rm{for\ each\ }}  i \in [1,\ N].\notag
\end{eqnarray}
%
%
Note that $\kappa$ represents the trade-off between the time for the result of execution and the sum of weight of satisfied soft constraints.
For example, we find the execution with the shortest time without considering soft constraints when $\kappa=1$, and the execution that maximizes the sum of weights of satisfied soft constraints is found without considering the time when $\kappa=0$.

The procedures to solve \rpbm{pbm2} is described in Algorithm 1 in detail. 
%
%
%
\begin{algorithm}
\caption{: FIND($G,\phi,\Psi,\Len,J_\kappa$): algorithm to solve \rpbm{pbm2}} \label{alg_solve_maxsat}
\begin{algorithmic}
%
\Require $G$, $\phi$, $\Psi=\{(\psi_i,weight);\ i\in[1,\ N]\}$, $\Len$, $J_\kappa$
\Ensure a finite execution $\pi$ 

\State Get $A$, $\alpha$, $\beta$ from a transition function of $G$

\State Set \req{w}-\req{zek3} 
\State Convert $\phi$ to \textit{ILP}($\phi$)
\If{$\Psi$ is not empty}

	\For{ $i \in [1,N]$}
	\State Convert $\psi_{i}$ to \textit{ILP}($\psi_{i}$) 
	\State Set $(z_{\psi_i}(0)=1,weight_i)$ as a soft constraint
	\EndFor
\EndIf
\State Set the objective function $J_\kappa$
\State Find an execution of $G$
\If{Succeed to find an execution}
	\State Return the execution 
\Else
	\State  Return $\bot$
\EndIf
\end{algorithmic}
\end{algorithm}
%
%%
%

%
In order to demonstrate effectiveness to partition the formula in \rpbm{pbm2}, 
we show an illustrative example of path planning and discuss how the optimal path depends on the weights for the soft constraints in the following section.
%

%
\subsection{Example}\label{sec:sim1}
%
In this section, we demonstrate the effectiveness of the proposed approach by a simulation of a path planning problem for a mobile robot.
\red{The simulation was run by a machine with AMD Ryzen9 5950X and 128GB memory, and the solver Gurobi\footnote{https://www.gurobi.com/} was used to compute an optimal solution of this ILP problem.}
%
\subsubsection{Setting of TDES}
\label{settingDES}
%
%
\begin{figure}
\centering 
\includegraphics[width=8cm]{1-c4-crop.pdf}
\caption{The untimed DES $G_{act}$ considered in \rsec{sec:sim1}.}
\label{sim1}
\end{figure}
%
We consider the system whose logical behavior is modeled by an untimed DES $G_{act}$ shown in \rfig{sim1}.
In the figure, each node represents the state of the system, and each edge represents the transition between them. 
The symbol $(e,l_e,u_e)$ near each edge represents the event  $e\in\Sigma_{act}$ associated with the edge, the lower time of $e$, and the upper time of $e$, respectively. The element in parentheses next to $s_i$ represents atomic propositions assigned to $s_i$ for $i\in[0,~5]$.
The initial state is $s_0$.
%
Based on the above definitions, the corresponding timed DES $G$ is constructed according to \rdef{def:G}. 
%
\subsubsection{Simulation result}
%
We consider the following hard constraint, and soft constraints and their weight.
\begin{align}
\phi=&\F{0,\Len}p_{fin},\notag \\
\Psi 
=&\{
(\psi_1=\G{0,\Len}(\lnot p_s),3),~
(\psi_2=\F{0,\Len}p_3,1),\notag \\
&~~(\psi_3=\F{0,\Len}p_4,1),~
(\psi=((\lnot p_4) \U{0,\Len} p_3,2)
\}.\notag
\end{align}
%
We use Gurobi to compute an optimal execution that optimizing the objective function $J_\kappa$. 
Let $\Len=20$. We compute optimal executions $\pi^1$, $\pi^2$, and $\pi^3$ with $\kappa=0.01,~0.5,1$, respectively, such that $\Pr(\pi^1)$, $\Pr(\pi^2)$, and $\Pr(\pi^3)$ are given by
\begin{align}
\Pr(\pi^1)=&
s_0,\ttick,s_0,\ttick,s_0,e_{03},s_3,\ttick,s_3,\ttick,\notag\\
&s_3,e_{34},s_4,\ttick,s_4,e_{40},s_0,e_{01},s_1,\notag\\
&\ttick,s_1,e_{12},s_2,\ttick,s_2,e_{25},s_5,\ldots,s_5\notag\\
\Pr(\pi^2)=&
s_0,\ttick,s_0,\ttick,s_0,e_{03},s_3,\ttick,\notag\\
&s_3,\ttick,s_3,e_{35},s_5,\ldots,s_5\notag \\
\Pr(\pi^3)=&s_0,e_{01},s_1,\ttick,s_1,e_{12},s_2,\ttick,s_2,e_{25},s_5,\ldots,s_5\notag
\end{align}
%
The time for $\pi^1$, $\pi^2$, and $\pi^3$ are 7, 4, and 2 [\tick], respectively.
The sum of weight of soft constraints satisfied by $\pi^1$, $\pi^2$, and $\pi^3$ are 4, 3, and 0.
The results of executions are shown that the combination of satisfied soft constraints is changed when the value of $\kappa$ is changed while satisfying the hard constraint.
%
%
\section{Two-level hierarchical TDESs}\label{def:htdes}
%
%
In the case where we find an execution for a very long length, the proposed ILP problem in the previous section becomes too large to solve it in a practical computational time. 
In order to overcome this problem, first, we introduce a hierarchical timed discrete event system (hierarchical TDES) \red{where the granularity of the unit time at the lower-level TDESs is finer than that at the upper-level TDES, and specifications are given for both the upper-level and lower-level TDESs. Then, we propose a hierarchical planning method for the hierarchical TDES\footnote{For simplicity, we focus on planning over a three-level hierarchical TDES, but the key idea can be generalized into planning with more than two levels.}.}

%
%階層プランニングはボトムアップのプランニングである。なので、まず下位TDESをProblem 1に従って、プランニングを行う。このとき、いくつかのαの値で実行列を求め、そのそれぞれについて、かかった時間とソフト制約の重みの合計を上位TDESに情報として与える。その情報をもとに上位TDESのプランニングを行う
\red{The proposed hierarchical planning is based on a  bottom-up approach.
So, we first compute several candidates of a lowest-level plan with a finer time scale for each state of the middle-level TDES using the corresponding lowest-level TDES such that the plan is optimal for the corresponding objective function.
Then, we find several candidates of a middle-level plan for the middle-level specification using the middle-level TDES such that a lowest-level plan at each refined state is determined(decided) of the candidates and all determined lowest-level plans are feasible under the middle-level plan.
Finally, we find an optimal top-level plan and determine a middle plan at each refined state for the top-level specification using the top-level TDES such that all middle plans are feasible under the top-level plan.
}
In the following, the DES used in the top-level planning, those in the middle-level planning, and those in the lowest-level planning will be denoted by $G_{act}$, $G_{i,act}$, and $G_{i,{j_i},act}$, respectively.  
$G_{act}$ is given by $G_{act}=(S_{act},\Sigma_{act},\delta_{act},s_{init,act},AP_{act},L_{act})$.
Moreover, for $i \in [1,\ M]$ and $j_i\in [1,~M_i]$, $G_{i,act}$ is given by $G_{i,act}=(S_{i,act},\Sigma_{i,act},\delta_{i,act},s_{init,i,act},AP_{i,act},L_{i,act})$, and $G_{i,{j_i},act}$ is given by $G_{i,{j_i},act}=(S_{i,{j_i},act}$, $\Sigma_{i,{j_i},act},\delta_{i,{j_i},act},s_{init,i,{j_i},act},AP_{i,{j_i},act},L_{i,{j_i},act})$.
%
$S_{act}$, $S_{i,act}$, and $S_{i,{j_i},act}$ are the sets of states, $\Sigma_{act}$, $\Sigma_{i,act}$, and $\Sigma_{i,{j_i},act}$ are the sets of events, $\delta_{act}$, $\delta_{i,act}$, and $\delta_{i,{j_i},act}$ are the transition functions, $s_{init,act}$, $s_{init,i,act}$, and $s_{init,i,{j_i},act}$ are the initial states, $AP_{act}$, $AP_{i,act}$, and $AP_{i,{j_i},act}$ are the sets of atomic propositions and $L_{act}$, $L_{i,act}$, and $L_{i,{j_i},act}$ are their corresponding labeling functions.
(We assume that $\Sigma_{act} \cap \Sigma_{i,act} = \emptyset,\Sigma_{i,act} \cap \Sigma_{i',act} = \emptyset$ for any $i,i'\in[1,\ M],\ i\neq i'$.)
%

%
%
\red{
In our proposed hierarchical TDES, TDESs correspond to atomic propositions of the next upper-level TDES.
Then, we assume that the set of atomic propositions $\AP_{act}$ ({\sl resp.} $\AP_{i,act}$) is partitioned into two sets $\AP_{act}^{R}$ and $\AP_{act}^{N}$ ({\sl resp.} $\AP_{i,act}^{R}$ and $\AP_{i,act}^{N}$).
The states where atomic propositions in $\AP_{act}^{R}$ and $\AP_{act}^{N}$ ({\sl resp.} $\AP_{i,act}^{R}$ and $\AP_{i,act}^{N}$) are assigned are refined and unrefined states, respectively.
%
$\AP_{act}^R$, $\AP_{act}^N$, $\AP_{act}^R$, and $\AP_{act}^N$ are given by
\begin{eqnarray}
\AP_{act}^R&=&\{\textit{p}_1,\textit{p}_2,\ldots,p_{M_1}\}, \notag \\
\AP_{act}^N&=&\{\textit{p}_{M+1},\textit{p}_{M+2},\ldots,p_{|\AP_{act}|}\},\notag \\
\AP_{i,act}^R&=&\{\textit{p}_{i,1},\textit{p}_{i,2},\ldots,p_{i,M_2}\}, \notag \\
\AP_{i,act}^N&=&\{\textit{p}_{i,M+1},\textit{p}_{i,M+2},\ldots,p_{|\AP_{i,act}|}\},\notag
\end{eqnarray}
%
with the following assumption.
%
\begin{align}
&\AP_{act}=\AP_{act}^R \cup \AP_{act}^N,~
\AP_{act}^R \cap \AP_{act}^N=\emptyset,\notag\\
&\AP_{i,act}=\AP_{i,act}^R \cup \AP_{i,act}^N,~
\AP_{i,act}^R \cap \AP_{i,act}^N=\emptyset,\notag\\
&\AP_{act}^R \cap \AP_{i,act}^R =\emptyset.\notag
\end{align}
%
For each state corresponding to $\textit{p}_i \in \AP_{act}^{R}$ ({\sl resp.} $p_{i,{j_i}}\in \AP_{i,act}^{R}$), we have a DES in the middle-level $G_{i, act}$ ({\sl resp.} in the lowest-level $G_{i,{j_i}, act}$) that models its local behaviors.}
%
According to \rsec{tdes}, we introduce TDESs corresponding to $G_{act}$, $G_{i,act}$, and $G_{i,{j_i},act}$ that are denoted by $G$, $G_{i}$, and $G_{i,{j_i}}$, respectively.
%
The granularity of the unit time of each system may be different, so its unit time is also different. 
We distinguish each unit time and introduce a corresponding special event that means the elapse of one unit time as follows.
%
Denoted by \tick$_p$ is a unit time of $G_{act}$, each \tick$_i (i\in[1,\ M])$ is a unit time of $G_{i,act}$, and each \tick$_{i,{j_i}} (i\in[1,\ M], j_i\in[1,\ M_i])$ is a unit time of $G_{i,{j_i},act}$. Then,  events $\textit{tick}_p$, $\textit{tick}_i$, and $\textit{tick}_{i,{j_i}}$ means the elapse of \tick$_p$, \tick$_{i}$, and \tick$_{i,{j_i}}$, respectively.
%
%
%
%
Timer interval $T_\sigma$, $T_{i,\sigma}$, and $T_{i,{j_i},\sigma}$ for each $\sigma\in\Sigma_{act}$, $\sigma\in\Sigma_{i,act}$, and $\sigma\in\Sigma_{i,{j_i},act}$ is given in the basis of \tick$_p$, \tick$_i$, and \tick$_{i,{j_i}}$, respectively.
%
%
Then, we denote the DES together with the corresponding unit time and the corresponding timer interval by
\begin{eqnarray}
\overline{G}&\coloneqq&(G_{act},\mbox{\tick}_p,T_{\sigma}),\notag \\
\overline{G_i}&\coloneqq&(G_{i,act},\mbox{\tick}_i,T_{i,\sigma}),\notag\\
\overline{G_{i,{j_i}}}&\coloneqq&(G_{i,{j_i},act},\mbox{\tick}_{i,{j_i}},T_{i,{j_i},\sigma}),\notag
\end{eqnarray}
respectively, where $i\in [1,\ M]$ and $j_i\in [1,\ M_i]$.
According to \rdef{def:G}, the TDES $G$ corresponding to $\overline{G}$ is given by a tuple $G=(S,\Sigma,\delta,s_{init},AP,L)$, for each $i\in[1,\ M]$, a TDES $G_i$ corresponding to $\overline{G_i}$ is given by a tuple $G_i=(S_{i},\Sigma_{i},\delta_{i},s_{init,i},AP_{i},L_{i})$, and, for each $i\in[1,\ M]$ and $j_i\in[1,\ M_i]$, a TDES $G_{i,{j_i}}$ corresponding to $\overline{G_{i,{j_i}}}$ is given by a tuple $G_{i,j_i}=(S_{i,{j_i}},\Sigma_{i,{j_i}},\delta_{i,{j_i}},s_{init,i},AP_{i,{j_i}},L_{i,{j_i}})$.
%
$S$, $S_i$, and $S_{i,{j_i}}$ are the sets of states, $\Sigma$, $\Sigma_i$, and $\Sigma_{i,{j_i}}$ are the sets of events, $\delta$, $\delta_i$, and $\delta_{i,{j_i}}$ are the transition functions, $s_{init}$, $s_{init,i}$, and $s_{init,i,{j_i}}$ are the initial states, $\AP$, $\AP_i$, and $\AP_{i,{j_i}}$ are the sets of atomic propositions and $L$, $L_i$, and $L_{i,{j_i}}$ are their corresponding labeling functions.
%
Executions of the $G$, $G_{i}$, and $G_{i,{j_i}}$ are given in the same way as \req{execution}. 
%
%
Then, we denote the three-level hierarchical TDES as follows. 
%
\begin{align}\label{htdes}
\mathcal{G}
=&\{\overline{G}, \overline{G_i}, \overline{G_{i,{j_i}}} \},
\end{align}
where $i\in[1,\ M]$ and $j_i\in[1,\ M_i]$.
%
%
\red{
\begin{exa}\label{exa:hier}
Consider a three-level hierarchical TDES consists of TDESs corresponding to DESs shown in \rfig{ex:htdes}.
For the top-level DES $G_{act}$, there are two states $s_1$ and $s_2$.
We set $\AP^R_{act}=\{p_1,p_2\}$ and $\AP^N_{act}=\{p_3\}$. Then, atomic propositions are assigned to each state as follows.
\[
L_{act}(s_{1}) = \{p_1,p_3\},~
L_{act}(s_{2}) = \{p_1,p_2\}.
\]
If $s_1$ or $s_2$ is stayed at in a top-level plan, a middle-level plan determined by the TDES $G_1$ corresponding to $G_{1,act}$ can be implemented.
If $s_2$ is stayed at in a top-level plan, both middle-level plans determined by $G_1$ and $G_2$ can be implemented in parallel.
For the middle-level DESs $G_{1,act}$ and $G_{1,act}$, we set a set of atomic propositions and label functions as follows. 
\[
\AP^R_{1,act}=\{p_{1,1}\},~\AP^N_{1,act}=\{p_{1,2}\},
\]
\[
\AP^R_{2,act}=\{p_{2,1}\},~\AP^N_{2,act}=\{p_{2,2}\},
\]
\[
L_{act}(s_{1}^1) = \{p_{1,1}\},~
L_{act}(s_{2}^1) = \{p_{1,2}\},
\]
\[
L_{act}(s_{1}^2) = \{p_{2,2}\},~
L_{act}(s_{2}^2) = \{p_{2,1}\},~
L_{act}(s_{3}^2) = \{p_{2,1}\}.
\]
Then, there are two lowest-level DESs $G_{1,1,act}$ and $G_{2,1,act}$ corresponding to $p_{1,1}$ and $p_{2,1}$, respectively.
\end{exa}
}
%
\begin{figure}
\centering
\includegraphics[width=8cm]{ex_htdes_2-crop.pdf}
\caption{The hierarchical TDES considered in Example \ref{exa:hier}.}
\label{ex:htdes}
\end{figure}
%
%
%
\red{\section{Hierarchical planning}}
%
We propose hierarchical planning for a three-level hierarchical TDES introduced in the previous section.
The plan is composed of the top-level plan, middle-level plans, and lowest-level plans determined by the specification given to $G$, $G_i$, and $G_{i,{j_i}}$ for $i\in [1,~M]$ and $j_i\in [1,~M_i]$, respectively.
An overall plan of the hierarchical TDES where plans are determined with considering some candidates of the next lower-level plans as an option is better than one considering a(only one)  local plan for each TDES.  
Thus, in each lowest planning and middle-level planning, candidates of a plan are created for the next upper-level planning.
Then, in top-level planning and middle-level planning, we find plans with considering the next lower-level candidates of plans and determine a lowest-level plan at each refined state of the candidates.
%
\subsection{Problem formulation}
%
We introduce $\pi(J)$, $m_{\pi(J)}$, and $W_{\pi(J)}$. 
$\pi(J)$ is an execution of a TDES $G'$ which optimizes an objective function $J$.
Let ${\tick}_{l}$ and ${\tick}_u$ be a unit time of the TDES $G'$ and one of the next upper-level TDES, respectively.
$m_{\pi(J)}$ is the time for $\pi(J)$ with respect to ${\tick}_{u}$ and given by
\begin{align}\label{ti}
m_{\pi(J)}=\left\lceil \left(\textit{count}_{\pi(J)}(0,\Len)+1\right)\cdot\frac{{\tick}_l}{{\tick}_{u}} \right\rceil,
\end{align}
where $\Len$ is a given length of $\pi(J)$, $(\textit{count}_{\pi(J)}(0,\Len)+1 )$ represents the time for $\pi(J)$ with respect to ${\tick}_l$, and $\lceil x \rceil =\min\{n\in\mathbb{Z}|\ x\leq n\}$.
Let $W_{\pi(J)}$ be the sum of weights of soft constraints that $\pi(J)$ satisfies.

In the first step of our proposed hierarchical planning, we compute executions of $G_{i,{j_i}}$ to create candidates of a lowest-level plan with the objective function $J_\kappa$ in \req{j1} for each $i\in[1,~M]$ and $j_i\in[1,~M_i]$.
%
%
To create candidates of a plan, we find executions of $G_{i,{j_i}}$ with some values of $\kappa$ since the results of execution are different when we change the value of $\kappa$ as shown in the examples of \rsec{sec4}.
%
A set of $\kappa$ is denoted as $K$ and given by
$K=\{\kappa_1,\ldots,\kappa_{|K|}\}$ with $\kappa_i\neq \kappa_j$ for $i,j\in [1,~|K|]$.
%
We give a hard constraint $\phi_{i,{j_i}}$ and a set of pairs of soft constraint and its weight $\Psi_{i,{j_i}}$ to $G_{i,{j_i}}$ for each $i\in[1,~M]$ and each $i_j\in[1,~M_i]$.
The result of execution of $G_{i,{j_i}}$ with the given length $\Len_{i,{j_i}}$ is denoted by $\pi_{i,{j_i}}(J_\kappa)$ which satisfies $\phi_{i,{j_i}}$ and optimizes the objective function $J_\kappa$.
%
%
Then, we define $\mathcal{M}_i$ and $\mathcal{W}_i$ as follows.
\begin{align}
\mathcal{M}_i&=\{m_{\pi_{i,{j_i}}(J_\kappa)}|~j_i\in[1,~M_i],~\kappa\in K\},\\
\mathcal{W}_i&=\{W_{\pi_{i,{j_i}}(J_\kappa)}|~j_i\in[1,~M_i],~\kappa\in K\}.
\end{align}
%
In the second step, for each $i\in[1,\ M]$, we compute executions of each middle-level TDES $G_i$ to create candidates of a plan.
Additionally, we consider $\M_i$ and $\W_i$ and determine a lowest-level plan at each refined state of the candidates in the middle-level planning. 
Then, to represent these properties in an objective function, we introduce the parameters $\lambda_1$ and $\lambda_2$ with $0\leq\lambda_1,{\lambda}_2\leq1$ and $\lambda_1+{\lambda}_2\leq1$.
$\lambda_1$ represents the importance of the time for the result of an execution, and $\lambda_2$ represents the importance of implementation of the task assigned to each lowest-level TDES $G_{i,{j_i}}$.
Moreover, $1-\lambda_1-\lambda_2$ represents the importance of the sum of weights of satisfied soft constraints.
We denote a pair of $\lambda_1$ and $\lambda_2$ by $\lambda$ and a set of some $\lambda$ by $\Lambda$, respectively.

Then, we define an objective function $J_{\lambda,\M,\W}$ with parameters in $\lambda\in\Lambda$ for middle-level TDESs, and create candidates of a plan represented by $\pi_{i}(J_{\lambda,\M,\W})$ for all $\lambda\in\Lambda$ and each $i\in[1,~M]$.
Then, we define $\mathcal{M}$ and $\mathcal{W}$ as follows.
\begin{align}
\mathcal{M}&=\{m_{\pi_{i}(J_{\lambda,\M,\W})}|~i\in[1,~M],~\lambda\in \Lambda\},\\
\mathcal{W}&=\{W_{\pi_{i}(J_{\lambda,\M,\W})}|~i\in[1,~M],~\lambda\in \Lambda\}.
\end{align}
%

In the third step, for the top-level plan, we find an execution of $G$ with a length $\Len$ and the specification given to $G$.
We assume that the top-level planning does not need to consider the time for the result of an execution.
Then, an execution of $G$ is computed with considering $\M$ and $\W$, and soft constraints while it satisfies a hard constraint in the top-level planning.
We denote a ratio of the importance of $\M$ and $\W$ to soft constraints by $\mu$ with $0\leq\mu\leq1$ and an objective function for the top-level planning by $J_{\mu,\M,\W}$.
%
In summary, we consider the following problem to find an execution of a three-level hierarchical TDES.
\begin{pbm}\label{pbm3}
Given a three-level hierarchical TDES $\mathcal{G}$, a hard constraint, denoted by $\phi$, $\phi_i$ and $\phi_{i,{j_i}}$, and a set of pairs of a soft constraint and its weight, denoted by $\Psi$, $\Psi_i$ and $\Psi_{i,{j_i}}$, for $G$, $G_i$ and $G_{i,{j_i}}$, respectively, the length $\Len(>0)$, $\Len_i(>0)$ and $\Len_{i,{j_i}}(>0)$ for $G$,  $G_i$ and $G_{i,{j_i}}$, respectively, ratios $K$, $\Lambda$ and $\mu$, and objective functions $J_\kappa$, $J_{\lambda,\M,\W}$ and $J_{\mu,\M,\W}$,
find finite executions $\pi_{i,{j_i}}(J_\kappa)$ of $G_{i,{j_i}}$ with $\Len_{i,{j_i}}$ for each $i\in[1,~M]$, each $j_i\in[1,~M_i]$ and all $\kappa\in K$ such that
\begin{eqnarray}
&\mbox{max: }&J_\kappa \notag \\
&\mbox{subject to: }&\pi_{i,{j_i}}(J_\kappa)\models \phi_{i,{j_i}}\mbox{, and transition lows of }G_{i,{j_i}}\notag 
\end{eqnarray}
Then, find finite executions $\pi_i(J_{\lambda,\M_i,\W_i})$ with $\Len_i$ for each $i\in[1,~M]$ and all $\lambda\in\Lambda$ such that
\begin{eqnarray}
&\mbox{max: }&J_{\lambda,\M_i,\W_i}\notag \\
&\mbox{subject to: }&\pi_i(J_{\lambda,\M,\W})\models \phi_i\mbox{, and transition lows of }G_i\notag 
\end{eqnarray}
 %
Finally, find a finite execution $\pi(J_{\mu,\M,\W})$ of $G$ with $\Len$ such that
\begin{eqnarray}
&\mbox{max: }&J_{\mu,\M,\W}\notag \\
&\mbox{subject to: }&\pi\models \phi\mbox{, and transition lows of }G\notag 
\end{eqnarray}
 %
\qedwhite
\end{pbm}
In the following, we define objective functions concretely and convert Problem \ref{pbm3} into an ILP problem(ILP problems).
\red{
\subsection{Optimization problem}}
%
%
We introduce $\Len_i + 1$ binary variables $z_{p_{i,{j_i}},\kappa}(k)\in\{0,~1\}$ for $k\in[0,~\Len_i]$, $i\in[1,~M]$, $j_i\in[1,~M_i]$, and $\kappa\in K$.
$z_{p_{i,{j_i}},\kappa}(k)=1$ means that the lowest plan of $G_{i,{j_i}}$ determined by $\pi_{i,j_i}(J_\kappa)$ is being  implemented at the $k$-th state in the execution of $G_i$.
$z_{p_{i,{j_i}},\kappa}(k)=1$ only if $p_{i,{j_i}}$ is true at the $k$-th state, i.e., $z_{p_{i,{j_i}}}(k)=1$.
Then, $z_{p_{i,{j_i}},\kappa}(k)$ follows the below equation.
\begin{align}\label{hier1}
{z}_{p_{i,{j_i}},\kappa}(k) \leq z_{p_{i,{j_i}}}(k).
\end{align}
%
We introduce two binary variables ${z}^{i,j_i}_\kappa$ and $z^{i,j_i}_{\phi_\kappa}$.
Each ${z}^{i,{j_i}}_\kappa(k)$ and $z^{i,{j_i}}_{\phi_\kappa}(k)$ are $\Len_i + 1$ binary variables for $k\in[0,~\Len_i]$.
${z}^{i,j_i}_\kappa(k)=1$ represents that the lowest plan determined by $\pi_{i,j_i}(J_\kappa)$ is started to operate at the $k$-th state of $\pi_i(J_\lambda)$.
$z^{i,j_i}_{\phi_\kappa}$ represents the constraint such that it takes $m_{\pi_{i,{j_i}}(\kappa)}$ [$\tick_i$] to implement the plan determined by $\pi_{i,{j_i}}(\kappa)$.
Once ${z}^{i,j_i}_\kappa=1$, ${z}^{i,j_i}_\kappa=0$ from the next state until the procedure is finished, i.e., $m_{\pi_{i,j_i}}(\kappa)$ $[\tick_i]$ passes.
%
${z}^{i,j_i}_\kappa$ and $z^{i,j_i}_{\phi_\kappa}$ follow the equation as below.
%
\begin{align}
&{z}^{i,j_i}_\kappa
\leq\G{0,m} z_{p_{i,j_i},\kappa},\label{hier2-1}\\
&z^{i,j_i}_{\phi_\kappa} (k)
\notag \\
&=\G{0,\Len_i}
%\{ 
\left(
{z}_\kappa^{i,j_i} (k)\to
%\notag \\&\hspace{1cm}
\bigwedge_{j=k+1}^{\Len_i}
\left(
\overline{z}_{m}
(k,j)\to \lnot {z}^{i,j_i}_\kappa (k)
\right)
%\right\},
\right)\label{hier2-2}
\end{align}
where $m$ denotes $m_{\pi_{i,j_i}}(\kappa)$ with the constraint $z^{i,{j_i}}_{\phi_\kappa}(0)=1 $.

%
%
Different candidates of a lowest-level plan can not be implemented at the same time, then
\begin{align}\label{hier3}
\sum_{\kappa\in K}{z}_{p_{i,{j_i}},\kappa}(k) \leq 1,~\mbox{for }\forall k\in[0,~\Len_i].
\end{align}
%
With $z_{p_{i,{j_i}},\kappa}(k)$, we introduce the objective function $J_{\lambda,\M_i,\W_i}$ for $G_i$ as follows.
\begin{align}
J_{\lambda,\M_i,\W_i}=&
-\lambda_1\sum_{k=1}^{\Len_i}z_e(k) 
\notag\\&~
+
{\lambda_2}\left(\sum_{j_i\in[1,~M_i]} \sum_{\kappa\in K} \sum_{k=0}^{\Len_i} {z}^{i,{j_i}}_\kappa(k) \cdot {W_{\pi_{i,{j_i}}(\kappa)}}\right)
\notag\\&~
+
(1-{\lambda_1}-{\lambda_2})\left(\sum_{n=1}^{N_i} w^i_{n}\cdot z_{\psi^i_{n}}(0)\right) ,\notag
\end{align}
where $\Psi_i=\{(\psi^i_n,w_n^i)|~n\in[1,N_i]\}$ is a set of $N_i$ pairs of soft constraint and its weight for $G_i$.
%
%
%

In the same way as $z_{p_{i,{j_i}},\kappa}$, we introduce  $\Len + 1$ binary variables $z_{p_{i},\lambda}$, $z_\lambda^i$, and $z^{i}_{\phi_\lambda} $.
%$z_{p_i,\lambda}(k)$, $z_\lambda^i$, and $z^{i}_{\phi_\lambda} $
These variables follow the below equations.
\begin{align}
&{z}_{p_{i},\lambda}(k) \leq z_{p_{i}}(k), \label{hier2-1}\\
%
&{z}^{i}_\lambda
\leq\G{0,m_{\pi_{i}(\lambda)}} z_{p_{i},\lambda},\label{hier2-2}\\
%
&z^{i}_{\phi_\lambda} (k)
\notag \\
&=\G{0,\Len_i}
\left(
{z}_\lambda^{i} (k)\to
\bigwedge_{j=k+1}^{\Len_i}
\left(
\overline{z}_{m_{\pi_{i}}(\lambda)}
(k,j)\to \lnot {z}^{i}_\lambda (k)
\right)
\right),\label{hier2-3}\\
%
&\sum_{\lambda\in\Lambda}{z}_{p_{i},\lambda}(k) \leq 1,\label{hier2-4}
\end{align}
where $z^{i}_{\phi_\lambda} (0)=1$.
%
With $z_{p_{i},\lambda}$, we introduce the objective function  $J_{\mu,\M,\W}$ for $G$ as follows.
\begin{align}
J_{\mu,\M,\W}=&
\mu\left(\sum_{i\in[1,~M]} \sum_{\lambda\in\Lambda} \sum_{k=0}^{\Len} {z}^i_\lambda
(k) \cdot W_{\pi_i(\lambda)}\right)
\notag\\
&~~~+
(1-\mu)\left(\sum_{n=1}^{N} w_{n}\cdot z_{\psi_{n}}(0)\right).\label{obj}\notag
\end{align}
%
Then, we convert \rpbm{pbm3} into the following ILP problem(s) by using the encodings considered in Section \ref{encode}. 
First, the ILP problem for finding finite executions of each $G_{i,j_i}$ with $\Len_{i,j_i}$ for all $\kappa\in K$ is given by
%
\begin{eqnarray}
&\mbox{max: }&J_\kappa \notag \\
&\mbox{subject to: }&\req{w}-\req{ckj},\ \textit{ILP}(\phi),\ \textit{ILP}(\psi_i),\notag\\
&&z_{\phi} (0) = 1, {\rm{for\ each\ }}  i \in [1,\ N],\notag\\ &&\tilde{\phi}_{i,{j_i},\kappa}(0)=1.\notag
\end{eqnarray}
%
Next, the ILP problem for finding a finite execution of  TDES $G_i$ ($i\in[1,~M]$) with $\Len_i$ is given by
\begin{eqnarray}
&\mbox{max: }&
J_{\lambda,\M,\W}\notag\\
&\mbox{subject to: }&\req{w}-\req{ckj},\ \textit{ILP}(\phi_i),\ \textit{ILP}(\psi^i_n),\notag\\
&&z_{\phi_i} (0) = 1, {\rm{for\ each\ }}  n \in [1,\ N_i],\notag\\&&\req{hier1}-\req{hier3},~ z^{i,{j_i}}_{\phi_\kappa}(0)=1 .\notag
\end{eqnarray}
%
Next, the ILP problem for finding a finite execution of $G$ with $\Len$ is given by
%
\begin{eqnarray}
&\mbox{max: }&
J_{\mu,\M,\W}\notag \\
&\mbox{subject to: }&\req{w}-\req{ckj},\ \textit{ILP}(\phi),\ \textit{ILP}(\psi_n),\notag\\
&&z_{\phi} (0) = 1, {\rm{for\ each\ }}  n \in [1,\ N],\notag\\&&\req{hier2-1}-\req{hier2-4},~ z^{i}_{\phi_\lambda}(0)=1.\notag
\end{eqnarray}
%
The procedures to solve Problem \ref{pbm3} is described in Algorithm \ref{alg2} in detail.
%
\begin{algorithm}
\caption{Hierarchical planning} \label{alg2}
\begin{algorithmic}
%
\State $\mathcal{M}=\emptyset,\mathcal{W}=\emptyset$
\For{ $i \in \{1,\ldots,M\}$}
\For{ $j \in \{1,\ldots,M_i\}$}
	\For{ $\kappa\in K$}
		\State ${\pi_{i,j_i}(\kappa)}$ = Find($G_{i,j_i},\phi_{i,j_i},\Psi_{i,j_i}\Len_{i,j_i},J_\kappa$).
		\If{${\pi_{i,j_i}(\kappa)}=\bot$}
		\State $\mathcal{M}_i=\mathcal{M}_i\cup\{0\}$, $\mathcal{W}_i=\mathcal{W}_i\cup\{-M_h\}$.
		\Else
		\State $m_{\pi_{i,j_i}(\kappa)}$
		\State \hspace{1cm}$=\left\lceil (\textit{count}_{\pi_{i,j_i}(\kappa)}(0,\Len_{i,j_i})+1)\frac{\tick_{i,j_i}}{\tick_i} \right\rceil $.
		\State Get $W_{\pi_{i,j_i}(\kappa)}$ from $\pi_{i,j_i}(\kappa)$.
		\State $\mathcal{M}_i=\mathcal{M}_i\cup\{m_{\pi_{i,j_i}(\kappa)}\}$.
		\State $\mathcal{W}_i=\mathcal{W}_i\cup\{W_{\pi_{i,j_i}(\kappa)}\}$.
		\EndIf
	\EndFor
\EndFor
\EndFor
\For{ $i \in \{1,\ldots,M\}$}
\For{ $\lambda\in \Lambda$}
		\State ${\pi_i(\lambda)}$ = Find($G_i,\phi_i,\Psi_i,\Len_i,J_{\lambda,\M_i,\W_i}$).
		\If{${\pi_{i}(\lambda)}=\bot$}
		\State $\mathcal{M}=\mathcal{M}\cup\{0\}$, $\mathcal{W}=\mathcal{W}\cup\{-M_h\}$.
		\Else
		\State $m_{\pi_i(\lambda)}=\left\lceil (\textit{count}_{\pi_i(\lambda)}(0,\Len_i)+1)\frac{\tick_i}{\tick_p} \right\rceil $.
		\State Get $W_{\pi_i(\lambda)}$ from $\pi_i(\lambda)$.
		\State $\mathcal{M}=\mathcal{M}\cup\{m_{\pi_i(\lambda)}\}$, $\mathcal{W}=\mathcal{W}\cup\{W_{\pi_i(\lambda)}\}$.
		\EndIf
\EndFor
\EndFor
%
\State ${\pi}$ = Find($G,\phi,\Psi,\Len,J_{\mu,\M,\W}$).
\end{algorithmic}
\end{algorithm}
%
%
%
%
\section{Illustrative example of hierarchical planning}\label{simResult}
%
%
%
We show an illustrative example of planning for a mobile robot modeled by a three-level hierarchical TDES. % introduced above section.
The effectiveness of the proposed approach is demonstrated by numerical simulation.
%
\subsection{Path planning with tasks}

\begin{figure}
   \centering
   \includegraphics[width=6cm]{p-crop.pdf}
   \caption{Grid model for the top-level DES considered in \rsec{simResult}. The left-top state(location) is $s_{0,act}$, the right-top state is $s_{5,act}$, the left-bottom state is $s_{30,act}$ and the right-bottom state is $s_{35,act}$. Atomic propositions assigned to green, red, yellow, and grey states are $p_1$, $p_2$, $p_3$, and $p_4$, respectively.}
    \label{pTDES}
    %\vspace{0.1cm}
\end{figure}
\begin{figure}
   \centering
    \subfigure[The DES $G_{act,1}$ corresponding to $p_1\in \AP_{act}$.]{\hspace{0cm}
      {\includegraphics[width=6cm]{c1-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,2}$ corresponding to $p_2\in \AP_{act}$.]{\hspace{0cm}      {\includegraphics[width=8cm]{c2_2-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,3}$ corresponding to $p_3\in \AP_{act}$.]{\hspace{0cm}
      {\includegraphics[width=7cm]{c3-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
    \caption{The untimed DESs used for the middle-level planning in the simulation of \rsec{simResult}. Each DES represents task procedure or behaviors of a system. Each node represents the state of the task, and each edge represents the transition between them. The element in parentheses in each state represents atomic propositions assigned to the state. The symbol $(e,l_e,u_e)$ near each edge represents the event  $e$ associated with the edge, the lower time of $e$, and the upper time of $e$.   } \label{cTDES}
    %\vspace{0.1cm}
\end{figure}
%

We consider a path planning problem where a robot moves the areas while doing tasks which is assigned to the corresponding states.
In the top-level planning, we consider an order to visit statesthat represent locations.
In middle-level planning, we determine plans to operate procedures of tasks. 
Then, in lowest-level planning, we determine plans of procedures in detail.
%
%
First, for the top-level planning, we introduce a DES $G_{act}$ for modeling behaviors of the robot 
 with the coarse granularity of the unit time as shown in \rfig{pTDES}.
%
In the figure, each grid represents a state and, for every state $s_i$, there are transitions between $s_i$ and the states connected to $s_i$ horizontally or vertically with the events $\textit{up}_i$, $\textit{down}_i$, $\textit{left}_i$, or $\textit{right}_i$.
%
The initial state $s_{init,act}$ is the left-top state $s_0$.
$\AP_{act}=\{p_i|~i\in[0,5]\}$ is the set of atomic propositions and the labeling function $L_{act}$ is given by
\begin{align}
&L_{act}(s_{ 10 }) =  p_1,\
L_{act}(s_{19}) =  p_1, \notag \\
&L_{act}(s') = p_2,\mbox{ for } s'\in\{s_{10},s_{11},s_{17}\}, \notag\\
&L_{act}(s_{ 31 }) = p_3,\ 
L_{act}(s_{ 34 }) =  p_3, \ 
L_{act}(s_{ 63 }) =  p_4,\notag\\
&L_{act}(s) =  p_5\mbox{ for other states.}%s\in S_{act}\setminus\{s_{ 12 },s_{ 14 },s_{30},s_{33},s_{34},s_{50},s_{63}\}.
\end{align}
We define $\AP_{act}^R=\{p_1,p_2,p_3\}$ and $\AP_{act}^N=\{p_4,p_5\}$ 
The time scale of $G_{act}$ is given by ${\tick}_p=100$, and, for all $\sigma\in \Sigma$, the timer interval is given by $T_\sigma=[1,\infty]$ in the basis of ${\tick}_p$.
%
%
Then, we introduce DESs for modeling procedures(behaviors) of systems used in middle-level planning as shown in \rfig{cTDES}.
We introduce three DESs, for $i=1,2,3$, $G_{i,act}=(S_{i,act}, \Sigma_{i,act}, \delta_{i,act},s_{init,i,act}, L_{i,act}, A_{i,act})$ corresponding to $p_i\in \textit{AP}$, respectively.
For $i=1,2,3$ and $j\in[0,\ |S_{i,act}|]$, the element in parentheses next to $s_j^i$ represents atomic propositions assigned to $s_j^i$.
%
The symbol $(e,l_e,u_e)$ near each edge represents the event  $e$ associated with the edge, the lower time of $e$, and the upper time of $e$.
We set $\AP_{1,act}^R=\{p_{1,1}\}$, $\AP_{2,act}^R=\{p_{2,1}\}$, and $\AP_{3,act}^R=\{p_{3,1},p_{3,2}\}$
%

%
$G_{1,act}$ represents a procedure to \textit{load a luggage}. At the states $s_{1,1}$ and $s_{1,2}$ where the atomic proposition $p_{1,1}$ is assigned, luggage is   loaded in the robot.
$G_{2,act}$ represents a Solar power generation system. 
The atomic proposition $p_{2,1}$ assigned to $s_1^2$ represents the state of checking battery.
$G_{3,act}$ represents two procedures using the same machine, and these two procedures can not be operated at the same time.
The atomic proposition $p_{3,1}$ assigned to $s_1^3$ and $s_3^3$ represents the state of using the machine.
At the states $s_2^3$ and $s_4^3$ where the atomic proposition $p_{3,2}$ is assigned, the machine is cleaned up.

%
%
%
%
The unit time $\tick_i$ of $G_{i,act}$ for each $i=1,2,3$ are given by
\begin{align}
&{\tick}_1=80,~{\tick}_2=90,~{\tick}_3=80,\notag\\
{\tick}_{1,1}=&70,~{\tick}_{2,1}=60,~{\tick}_{3,1}=70,~{\tick}_{3,2}=50,\notag
\end{align}
respectively.
%
%

\begin{figure}
   \centering
    \subfigure[The DES $G_{act,1,1}$ corresponding to $p_{1,1}\in \AP_{1,act}$.]{\hspace{0cm}
      {\includegraphics[width=6cm]{l_1_1-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,2,1}$ corresponding to $p_{2,1}\in \AP_{2,act}$.]{\hspace{0cm}      {\includegraphics[width=5cm]{l_2_1-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,3,1}$ corresponding to $p_{3,1}\in \AP_{3,act}$.]{\hspace{0cm}
      {\includegraphics[width=7cm]{l_3_1-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
      \subfigure[The DES $G_{act,3,2}$ corresponding to $p_{3,2}\in \AP_{3,act}$.]{\hspace{0cm}
      {\includegraphics[width=7cm]{l_3_2-crop.pdf}\hspace{0.0cm}} \label{exa_des}} \vspace{0.0cm}
    \caption{The untimed DESs used for the lowest-level planning in the simulation of \rsec{simResult}. Each DES represents task procedure or behaviors of a system.  } \label{l:TDES}
    %\vspace{0.1cm}
\end{figure}
%
Finally, we introduce DESs for modeling procedures(behaviors) of systems used in the lowest-level planning as shown in \rfig{l:TDES}.
%
From the above settings for DESs, we have the three-level hierarchical TDES with eight TDESs. 
%
\subsection{Specifications for hierarchical planning}
%
To determine a hierarchical plan for the robot, we give a specification for each TDES.
For the top-level TDES $G$, a hard constraint $\phi$ and a set of pairs of a soft constraint and its weight $\Psi$ are given by
\begin{align}
\phi=&\F{0,\Len}\G{0,2}p_1\land \F{0,\Len}\G{0,3}p_3\land (\lnot p_3)\U{0,\Len}p_1, \notag \\
\Psi=&\{
(\psi_1=\G{1,5}\lnot p_4, 2), ~
(\psi_2=\F{0,\Len}\G{0,2}p_2, 1),\notag\\&~
(\psi_3=\F{0,\Len}\G{0,4}p_2, 2),~
(\psi_4=\F{0,\Len}\G{0,4}p_3, 3),\notag\\&~
(\psi_5=\F{0,\Len}(p_1\land p_2),1)
\}.\notag
\end{align}
%
A hard constraint $\phi^i$ and a set of pairs of a soft constraint and its weight $\Psi^i$ for each $G_i$ are as follows, respectively.
\begin{align}
\phi^1=&\F{0,\Len_1}p_{1,5},\notag \\
\Psi^1 
=&\{
(\psi^1_{1} =\F{0,\Len_1}p_{1,4}, 1),~
(\psi^1_{2} =\F{0,\Len_1}\G{0,5}p_{1,3},2),\notag\\
&~(\psi^1_{3} =\F{0,\Len_1}\G{0,5}p_{1,4},1), \notag\\
&~(\psi^1_{4} =(\lnot p_{1,4}) \U{0,\Len_1}p_{1,3}, 2)
\} ,\notag
\\
\phi^2=&\F{0,\Len_2}p_{4},\notag \\
\Psi^2
=&\{
(\psi^2_{1}=\F{0,\Len_2}\G{0,4}p_{2,3},2)\notag\\
&~
(\psi^2_{2}=\F{0,\Len_2}\G{0,4}(\lnot p_{2,1}),1),\notag\\
&~(\psi^2_{3}=\G{0,\Len_2}\{(\lnot p_{2,3}) \lor (\lnot\F{0,\Len_2}p_{2,1})\},1)
\},\notag
\\ % r はready
\phi^{3}=&\F{0,\Len_3}p_{3,6},\notag \\
\Psi^3
=&\{
(\psi^3_{1}=\F{0,\Len_3}p_{3,4}, 3),~
(\psi^3_{2}=(\G{4,6}\lnot p_{3,5}, 2),\notag \\&~
(\psi^3_{3}=(\F{0,\Len_3}(\G{0,3}p_{3,2}), 3),\notag \\&~
(\psi^3_{4}=(\lnot p_{3,5})\U{0,5}p_{3,4}, 2)
\} .
\notag
\end{align}
%
Then, a hard constraint $\phi^{i,{j_i}}$ and a set of pairs of a soft constraint and its weight $\Psi^{i,{j_i}}$ for each $G_{i,{j_i}}$ are as follows, respectively.
%
\begin{align}
\phi^{1,1}=&\F{0,\Len_{1,1}}p_{1,1,4},\notag \\
\Psi^{1,1} 
=&\{
(\psi^{1,1}_1 =\F{0,\Len_{1,1}}p_{1,1,3}, 2),~
(\psi^{1,1}_2 =\F{0,5}p_{1,1,4},3),\notag\\
&~(\psi^{1,1}_4 =(\lnot p_2^{1,1}) \U{0,\Len_{1,1}}p_3^{1,1}, 2)
\} ,\notag
\\
%
%
\phi^{2,1}=&\F{0,\Len_{2,1}}p_{2,1,4},\notag \\
\Psi^{2,1} 
=&\{
(\psi^{2,1}_1=\F{0,\Len_{2,1}}\G{0,4}p_{2,1,3},2),\notag \\&~
(\psi^{2,1}_2=\F{0,\Len_{2,1}}\G{0,5}(\lnot p_{2,1,3}),1),\notag\\&~
(\psi^{2,1}_3= \lnot p_{2,1,2} \lor \F{3,15}(\lnot p_{2,1,2}),1)
\},\notag
\\ % r はready
\phi^{3,1}=&\F{0,\Len_{3,1}}p_{3,1,5},\notag \\
\Psi^{3,1} 
=&\{
(\psi^{3,1}_1=\F{0,\Len_{3,1}}(\G{0,4}p_{3,1,1}, 2),\notag \\
&~(\psi^{3,1}_2=(\F{0,\Len_{3,1}}(p_{3,1,4}\land \F{0,4}p_{3,1,2}), 3),\notag \\
&~(\psi^{3,1}_3=\F{0,\Len_{3,1}}p_{3,1,3}, 2),\notag \\
&~
(\psi^{3,1}_4=\G{3,6}(\lnot p_{3,1,2}), 3)
\} ,
\notag \\
\phi^{3,2}=&\F{0,\Len_{3,2}}p_{3,2,5} ,\notag \\
\Psi^{3,2} 
=&\{
(\psi^{3,2}_1=\F{0,\Len_{3,2}}\G{0,5}p_{3,2,3}, 3),\notag \\
&~
(\psi^{3,2}_2=\G{0,\Len_{3,2}}(\lnot p_{3,2,2}\lor\F{0,\Len_{3,2}}(\lnot p_{3,2,3})), 2),\notag \\
&~(\psi^{3,2}_3=\F{0,\Len_{3,2}}p_{3,2,3}, 1),~
(\psi^{3,2}_4=\G{2,5}\lnot p_{3,2,4}, 2)\}
 .\notag
\end{align}
%
%
%
\subsection{Results}
%
The length of execution for each TDES is given by
\begin{align*}
\Len = 30,~\Len_1=15,&~\Len_2=18,~\Len_3=20,
\\
\Len_{1,1} = 12,~\Len_{2,1}=15,&~\Len_{3,1}=20,~\Len_{3,2}=20.
\end{align*}
Let $K=\{1,~0.5,~0.01\}$ and $\Lambda=\{(1.0,~0),~(0.33,~0.33),~(0.1,~0.1)\}$. 
Additionally, $(1.0,~0)$, $(0.33,~0.33)$, and $(0.1,~0.1)$ are denoted by $\lambda_1$, $\lambda_2$, and $\lambda_3$, respectively.
%, and $\mu=0.5$.
%
We compute executions of the bottom-level TDESs for each $\kappa\in K$.
Then, we compute executions of the middle-level TDESs for each $\lambda\in\Lambda$.
In Table \ref{tab:mw}, we show the time for each results of execution and the sum of weight of soft constraints that the execution satisfies.
{\renewcommand\arraystretch{1.5}
\begin{table}[h]
\caption{The time for each results of execution, denoted by Time, and the sum of weight of soft constraints that the execution satisfies, denoted by Sum of weights.
}\label{tab:mw}
\begin{subfigmatrix}{2}
\subtable[The result of the bottom-level TDESs. Time and $W$ are equal to $m_{\pi_{i,j_i}(J_\kappa)}$ and $W_{\pi_{i,j_i}(J_\kappa)}$, respectively. Soft denotes satisfied soft constraints.]{
\begin{tabular}{c|c|c|c|c}
%
% 
&$\kappa\in K$ & Time  & Soft & $W$\\
\hline
			& 1			& 2 &$\psi^{1,1}_2$&3  \\
$G_{1,1}$ 	& 0.5 	& 2   &$\psi^{1,1}_2$  &3\\
			& 0.01 		& 7 &$\psi^{1,1}_1,\psi^{1,1}_3$&4 \\
\hline			
			& 1			& 4 &$\psi^{2,1}_3$&1   \\
$G_{2,1}$ 	& 0.5 	& 4  &$\psi^{2,1}_2,\psi^{2,1}_3$&2 \\
			& 0.01 		& 5 &All &4  %$\psi^{2,1}_1,\psi^{2,1}_2,\psi^{2,1}_3$ 
			\\
\hline	
			& 1 			& 1 &$\psi^{3,1}_4$ &3  \\
$G_{3,1}$ 	& 0.5 	& 4 &$\psi^{3,1}_2,\psi^{3,1}_3,\psi^{3,1}_4$  &8 
\\
			& 0.01 		& 7 &All&10  %$\psi^{3,1}_1,\psi^{3,1}_2,\psi^{3,1}_3,\psi^{3,1}_4$  
			\\
\hline	
			& 1 			& 3 &$\psi^{3,2}_2$ &2  \\
$G_{3,2}$ 	& 0.5 	& 5 &All &8 \\
			& 0.01 		& 5 &All  &8 \\
\end{tabular}\label{tab:mw:mid}}
%
%  \hfill
  %
\subtable[The result of the middle-level TDESs. Time and $W$ are equal to $m_{\pi_i(J_{\lambda,\M,\W})}$ and $W_{\pi_i(J_{\lambda,\M,\W})}$, respectively. Soft and Task denote satisfied soft constraints and implemented tasks which are  determined by bottom-level plans.]{
\centering
\begin{tabular}{c|c|c|c|c|c}
%
%$W_{\pi_i(J_{\lambda,\M,\W})}$ 
& $\lambda\in \Lambda$& Time&Soft & $W$&Task\\
%(0.1~0.1) (0.33,~0.33), (1,~0)
\hline
			& (1,~0) 		& 3  & $\psi^{1}_4$&2 & \\
$G_1$ 	& (0.33,~0.33) 		& 8 & $\psi^{1}_1,\psi^{1}_4$&3&$\pi_{1,1}(J_{1})$, $\pi_{1,1}(J_{0.5})$  \\
			& (0.1,~0.1)	& 8 & $\psi^{1}_1,\psi^{1}_4$&3  &$\pi_{1,1}(J_{1})$, $\pi_{1,1}(J_{0.5})$ \\
\hline			
			& (1,~0)		& 3 & $\psi^{2}_3$&1  \\
$G_2$ 	& (0.33,~0.33) 		& 6 & $\psi^{2}_2,\psi^{2}_3$&2  &$\pi_{2,1}(J_{0.01})$ \\
			& (0.1,~0.1)	& 9&All   &4  &$\pi_{2,1}(J_{0.01})$ \\
\hline	
			& (1,~0) 		& 5 & $\psi^{3}_2$ &2 \\
$G_3$ 	& (0.33,~0.33) 		& 12 &All&10  &$\pi_{3,1}(J_{1})$, $\pi_{3,2}(J_{0.5})$   \\
			& (0.1,~0.1) 	& 12&All  &10 &$\pi_{3,1}(J_{1})$, $\pi_{3,2}(J_{0.5})$ \\
\end{tabular}\label{tab:mw:bot}}
\end{subfigmatrix}
\end{table}
}
%
In the following, we compute two executions of $G$ with $\mu=0.1$ and $0.5$.
Note that satisfaction soft constraints is more important than implementation of tasks determined by bottom-level plans when we set $\mu=0.1$.

For each value of $\mu$, the path of robot determined by the execution is shown in shown in \rfig{p:result}, and satisfied soft constraints, the sum of weights of them and implemented tasks are in Table \ref{tab:p}.

When $\mu=0.1$, all soft constraints are satisfied, and tasks determined by the executions of $G_1$, $G_2$, and $G_3$ are implemented.
However, every task satisfies only the hard constraint with the minimum required time and do not implemented any bottom-level tasks. 
On the other hand, when $\mu=0.5$, satisfied soft constraints are $\psi_1$ and $\psi_4$ and tasks determined by $G_1$ and $G_3$.
Since the execution with $\mu=0.5$ focuses on the  implementation of tasks is  more than that with $\mu=0.1$
Since the implementation of tasks is as important as the satisfaction of soft constraints when $\mu = 0.5$, the task determined by $\pi_3(J_{\lambda_3})$ is implemented.

The robot stays at $s_{10,act}$ between [\tick] and [\tick] and implements the task determined by $\pi_{}$ and $\pi_{}$.
Then, the robot moves to $s_{34,act}$.

\begin{figure}
   \centering
   \includegraphics[width=6cm]{p_result_mu-01-05-crop.pdf}
   \caption{The path determined by the result of execution. Black ({\sl resp.} blue) arrows represents the path optimizing the objective function with $\mu=0.1$ ({\sl resp.} $\mu=0.5$). The numbers in four grids represent the time the robot stays at the grids.}
    \label{p:result}
    %\vspace{0.1cm}
\end{figure}
%
%
\begin{table}
\caption{The result of the top-level TDESs. Soft, $W$, and Task are denote satisfied soft constraints, the sum of weights of them, and implemented tasks.}
\label{tab:p}
\centering
\begin{tabular}{c|c|c|ccc}
 $\mu$ &Soft& $W$&Task\\\hline
0.1& All &9 &  $\pi_1(J_{\lambda_1})$, $\pi_2(J_{\lambda_1})$, $\pi_3(J_{\lambda_1})$\\
0.5& $\psi_1$, $\psi_4$  &5 & $\pi_1(J_{\lambda_1})$, $\pi_3(J_{\lambda_3})$\\
\end{tabular}
\end{table}
%
%
\begin{comment}
%
%
\begin{figure}
   \centering
    \subfigure[The path optimizing the cost function with $\mu=0.1$.]{\hspace{0cm}
      {\includegraphics[width=5cm]{p_result_mu-01-crop.pdf}\hspace{0.0cm}} \label{p:r:01}} \vspace{0.0cm}
      \subfigure[The path optimizing the cost function with $\mu=0.5$.]{\hspace{0cm}      {\includegraphics[width=5cm]{p_result_mu-05-crop.pdf}\hspace{0.0cm}} \label{p:r:05}} \vspace{0.0cm}
    \caption{The path determined by the result of execution. } \label{p:result}
    %\vspace{0.1cm}
\end{figure}
%
%
%
\end{comment}
%
%
\section{efficiency of our method(kari)}
%
In this section, we consider(confirm) the efficiency of our proposed method.
We consider three (cases of a) three-level hierarchical TDES $\mathcal{G}_1$, $\mathcal{G}_2$, $\mathcal{G}_3$, and $\mathcal{G}_4$.
$\mathcal{G}_i$ for all $i=[1,~4]$ have one top-level TDES $G$.
In $\mathcal{G}_i$ for $i=[1,~4]$, there are one, one, two, and two middle-level TDESs $G_i$, and one, two, three and four bottom-level TDESs, respectively.
We introduce TDESs of $\mathcal{G}_i$ for $i=[1,~4]$ as follows.

In every TDES of each hierarchical TDES, there are four states and transitions between pairs of states that are different from each other.
We define the initial state and the final state states, then the two states other than the initial state and the final state are defined as refined states.
There is a transition from the final state to the final state, called \textit{self transition}.
The unit time of the top-level TDES, middle-level TDESs, and bottom-level TDESs are given by 40, 20, and 10, respectively.
In the basis of the unit time of each TDES, a timer interval for the  self transition is given by $[0,\infty]$ and those for other events are given by $[1,\infty]$.
For each TDES, a hard constraint represents ``the final state  is eventually achieved''.
Additionally, soft constraints represents ``the state $s$ is eventually achieved '' where $s$ is a state of the TDES other than the initial state and the final state, and weights of all soft constraints is 1.

For comparison, we introduce a TDES $\tilde{G}_i$ corresponding to $\mathcal{G}_i$ for $i=[1,~4]$.
In $\tilde{G}_i$, two types of transitions are added.
The first is a transition from each refined state to  the initial state of the corresponding next lower-level TDES. 
The second is a transition from each final state to the refined state of the corresponding next upper-level TDES.
The unit time of every $\tilde{G}_i$ is given by 10.
Then, the timer intervals of events corresponding to these two types of transitions are given by $[0,\infty]$.
Additionally, timer intervals of events of the top-level TDES ({\sl resp.} middle-level TDESs), originally, are given by $[4,~\infty]$ ({\sl resp.} $[2,~\infty]$).
A hard constraint for $\tilde{G}_i$ is given by ``the state, which was originally the final state of the top-level TDES, is eventually achieved''.
Soft constraints represents ``states of $\tilde{G}_i$, which were not originally the initial state and the final state, are eventually achieved'' and weights of all soft constraints are 1.

We consider the computational time and the sum of weights of satisfied soft constraints.
In the hierarchical planning, ``the computational time'' represents the time that it takes to compute executions of all TDESs for all $\kappa\in K$ and $\lambda\in \Lambda$, and ``satisfied soft constraints'' means soft constraints satisfied by one of candidates determined by the upper-level plans.
Note that, in this comparison, the results of execution which it takes more than one hour to compute are invalid.
Let $K=\{1,~0.5,~0.01\}$, $\Lambda=\{(1.0,~0),~(0.33,~0.33),~(0.1,~0.1)\}$, and $\mu=0.1$. 
Then, the results are shown in Table \ref{tab:comp}.
\begin{table}[h]
\caption{* in column denotes the invalid results.}\label{tab:comp}
\centering
\begin{tabular}{c||c|c|c|c}
&\multicolumn{2}{c|}{Time [sec]}  &\multicolumn{2}{c}{Sum of weights} \\\cline{2-5}
&Hierarchical TDES& TDES&Hierarchical TDES& TDES \\
\hline
$\mathcal{G}_1,~\tilde{G}_1$&25.0   & 36.9 &  6(all) &  5\\
$\mathcal{G}_2,~\tilde{G}_2$& 91.9  &  135.3&  8(all)  & 6\\
$\mathcal{G}_3,~\tilde{G}_3$& 105.9  & * &  6(all-6)  &* \\
$\mathcal{G}_4,~\tilde{G}_4$& 177.1  & * &  8(all-6)  & *\\
\end{tabular}
\end{table}

%
%
\section{Conclusion}
%

In this paper, we considered two approaches to a planning problem for a real-time system where a specification is given by an LTL$_f$ formula.
One is to relax the specification by partitioning the specification into a hard constraint and a set of pairs of a  soft constraint and its weight. 
Then, we formulated the problem with these constraints as an ILP problem.
The other approach is hierarchical planning that allows to reduce the computational costs.
For this approach, we proposed a hierarchical TDES and we especially considered a two-level hierarchical TDES that is composed of one upper level TDES and several lower level TDESs with different time-scales.
Each lower level TDES describes detailed behaviors in the corresponding state in the upper level TDES.
We proposed an algorithm of hierarchical planning where a rough plan is determined by using the upper level TDES and detailed plans are determined by using lower level TDESs.
%
It is future work to apply the proposed approaches to control of multi-agent systems.
%
%
%
%
\begin{thebibliography}{99}

\bibitem{CL2008}%
C.~G.~Cassandras and S.~Lafortune.
\newblock {\em Introduction to Discrete Event Systems}.
\newblock Springer, 2009.

\bibitem{CSX2018}%
J.~Campos, C.~Seatzu, and X.~Xie.
\newblock {\em Formal Methods in Manufacturing}.
\newblock CRC press, 2014.

\bibitem{SSS2013}%
C.~Seatzu, M.~Silva, and J.~H.~van Schuppen.
\newblock \emph{Control of Discrete Event Systems. Automata and Petri Net Perspective, Letcure Notes in Control and Information Science}. vol.~433,
\newblock Springer, 2013.

\bibitem{ghallab2016automated}
M.~Ghallab, D.~Nau, and P.~Traverso.
\newblock {\em Automated Planning and Acting}.
\newblock Cambridge University Press, 2016.

\bibitem{ramadge1987supervisory}%
P.~J.~Ramadge, and W.~M.~Wonham.
\newblock Supervisory control of a class of discrete event processes.
\newblock {\em SIAM Journal on Control and Optimization}, vol.~25, no.~1, pages 206--230, 1987.

\bibitem{TW1986}%
J.~G.~Thistle and W.~M.~Wonham.
\newblock Control problems in a temporal logic framework.
\newblock {\em International Journal of Control}, vol.~44, no.~4, pages 943--976, 1986.

\bibitem{JK2006}%
S.~Jiang and R.~Kumar.
\newblock Supervisory control of discrete event systems with CTL* temporal logic specifications.
\newblock {\em SIAM Journal on Control and Optimization}, vol.~44, no.~6, pages 2079--2103, 2006.

\bibitem{SU2018}%
A.~Sakakibara and T.~Ushio.
\newblock Decentralized supervision and coordination of concurrent discrete event systems under LTL constraints.
\newblock In \emph{Proceedings 14th Workshop on Discrete Event Systems}, pages 18--23, 2018.

\bibitem{GV1999}%
G.~de. Giacomo and M.~Y.~Vardi.
\newblock Automata-theoretic approach to planning for temporally extended goals.
\newblock In {\em Proceedings of European Conference on Planning}, pages 226--238, Springer, 1999.

\bibitem{BK2008}%
C.~Baier and J.-P.~Katoen.
\newblock {\em Principles of Model Checking}.
\newblock MIT press, 2008.

\bibitem{BHJLS2006}%
A.~Biere, K.~Heljanko, T.~Junttila, T.~Latvala, and V.~Schuppan.
\newblock Linear encodings of bounded LTL model checking.
\newblock \emph{Logical Methods in Computer Science}, vol.~2, no.~5, pages 1--64, 2006.

\bibitem{S2016}%
Y.~Shoukry, P.~Nuzzo, I.~Saha, A.~L.~Sangiovanni-Vincentelli, S.~A.~Seshia, G.~J.~Pappas, and P.~Tabuada.
\newblock Scalable lazy SMT-based motion planning.
\newblock In {\em Proceedings of 55th IEEE Conference on Decision and Control}, pages 6683--6688, 2016.

\bibitem{sahin2019multirobot}%
Y.~E.~Sahin, P.~Nilsson, and N.~Ozay.
\newblock Multirobot coordination with counting temporal logics.
\newblock {\em IEEE Transactions on Robotics}, 2019.

\bibitem{kupferman2001model}%
O.~Kupferman and M.~Y.~Vardi.
\newblock Model checking of safety properties.
\newblock {\em Formal Methods in System Design}, vol.~19, no.~3, pages 291--314, 2001.

\bibitem{cho2017cost}%
K.~Cho, J.~Suh, C.~J.~Tomlin, and S.~Oh.
\newblock Cost-aware path planning under co-safe temporal logic specifications.
\newblock {\em IEEE Robotics and Automation Letters}, vol.~2, no.~4, pages 2308--2315, 2017.

\bibitem{feyzabadi2016multi}%
S.~Feyzabadi and S.~Carpin.
\newblock Multi-objective planning with multiple high level task specifications.
\newblock In {\em Proceedings of the 2016 IEEE International Conference on Robotics and Automation}, pages 5483--5490, 2016.

\bibitem{Zhu2017}%
S.~Zhu, L.~M.~Tabajara, J.~Li, G.~Pu, and M.~Y.~Vardi.
\newblock Symbolic LTL$_f$ synthesis.
\newblock In {\em  Proceedings of the 2017 International Joint Conferences on Artificial Intelligence}, pages 1362--1369, 2017.

\bibitem{li2019sat}%
J.~Li, K.~Y.~Rozier, G.~Pu, Y.~Zhang, and M.~Y.~Vardi.
\newblock Sat-based explicit LTL$_f$ satisfiability checking.
\newblock In {\em Proceedings of the AAAI Conference on Artificial Intelligence}, vol.~33, pages 2946--2953, 2019.

\bibitem{camacho2019strong}%
A.~Camacho and S.~A.~McIlraith.
\newblock Strong fully observable non-deterministic planning with LTL and LTL$_f$ goals.
\newblock In {\em Proceedings of the 2019 International Joint Conferences on Artificial Intelligence}, pages 5523--5531, 2019.

\bibitem{BW1994}%
B.~A.~{Brandin} and W.~M.~{Wonham}.
\newblock Supervisory control of timed discrete-event systems.
\newblock {\em IEEE Transactions on Automatic Control}, vol.~39, no.~2, pages 329--342, 1994.

\bibitem{K1990}%
R.~Koymans.
\newblock Specifying real-time properties with metric temporal logic.
\newblock {\em Real-time systems}, vol.~2, no.~4, pages 255--299, 1990.

\bibitem{BKD1998}
M.~Barveau, F.~Kabanza, and R.~St.~Denis.
\newblock A method for the synthesis of controllers to handle safety, liveness, and real-time constraints.
\newblock {\em IEEE Transactions on Automatic Control}, vol.~43, no.~11, pages 1543--1559, 1998.

\bibitem{DS2014}%
A.~Dhananjayan and K.~T.~Seow.
\newblock A metric temporal logic specification interface for real-time discrete-event control.
\newblock {\em IEEE Transactions on Systems, Man, and Cybernetics: Systems}, vol.~44, no.~9, pages 1204--1215, 2014.

\bibitem{KHU2020}%
T.~Kinugawa, K.~Hashimoto, and T.~Ushio.
\newblock Control of timed discrete event systems with ticked linear temporal logic constraints.
\newblock In {\em Preprint of 21st IFAC World Congress}, 2020.

\bibitem{AKW2008}%
R.~Alur, A.~Kanade, and G.~Weiss.
\newblock Ranking automata and games for prioritized requirements.
\newblock In {\em Proceedings of the 20th International Conference of Computer Aided Verification}, pages 240--253, 2008.

\bibitem{DGT2018}%
R.~Dimitrova, M.~Ghasemi, and U.~Topcu.
\newblock Maximum realizability for linear temporal logic specifications.
\newblock In {\em International Symposium on Automated Technology for Verification and Analysis}, pages 458--475, Springer, 2018.

\bibitem{QC2000}%
M.~H.~de Queiroz and J.~E.~R.~Cury.
\newblock Modular supervisory control of large scale discrete event systems.
\newblock In {\em Discrete Event Systems:  Analysis and Control edited by R.\ Boel and G.\ Stremersch}, pages 103--110, Springer, 2000.

\bibitem{WW1996a}%
K.~C.~Wong and W.~M.~Wonham.
\newblock Hierarchical control of discrete-event systems.
\newblock {\em Discrete Event Dynamic Systems}, vol.~6, no.~3, pages 241--273, 1996.

\bibitem{WW1996b}%
K.~C.~Wong and W.~M.~Wonham.
\newblock Hierarchical control of timed discrete-event systems.
\newblock {\em Discrete Event Dynamic Systems}, vol.~6, no.~3, pages 275--306, 1996.

\bibitem{GAUDIN2004131}
B.~Gaudin and H.~Marchand.
\newblock Supervisory control of product and hierarchical discrete event systems.
\newblock {\em European Journal of Control}, vol.~10, no.~2, pages 131--145, 2004.

\bibitem{Ngo2018}%
Q.~H.~Ngo and K.~T.~Seow.
\newblock A hierarchical consistency framework for real-time supervisory control.
\newblock {\em Discrete Event Dynamic Systems}, vol.~28, no.~3, pages 375--426, 2018.

\bibitem{8759973}%
M.~{Goorden}, J.~van de Mortel-Fronczak, M.~{Reniers}, W.~{Fokkink}, and J.~{Rooda}.
\newblock Structuring multilevel discrete-event systems with dependence structure matrices.
\newblock {\em IEEE Transactions on Automatic Control}, vol.~65, no.~4, pages 1625--1639, 2020.

\bibitem{7497833}%
J.~{Komenda}, T.~{Masopust}, and J.~H.~van~Schuppen.
\newblock Control of an engineering-structured multilevel discrete-event system.
\newblock In {\em Proceedings of the 13th International Workshop on Discrete Event Systems}, pages 103--108, 2016.

\end{thebibliography}

%\begin{IEEEbiography}
\begin{IEEEbiographynophoto}{Takuma Kinugawa}
received his B. E. degree in 2020 from Osaka University. He is currently an M. E. candidate at Graduate School of Engineering Science, Osaka University. His research interests include control of real-time systems using temporal logic.
%\end{IEEEbiography}
\end{IEEEbiographynophoto}
%
%\begin{IEEEbiography}{Toshimitsu Ushio}
\begin{IEEEbiographynophoto}{Toshimitsu Ushio}
received his B. E., M. E., and Ph. D. degrees in 1980, 1982, and 1985, respectively,
from Kobe University.  He joined Osaka University as an Associate Professor in 1994, and is currently a Professor. His research interests include control and analysis of discrete event systems and hybrid systems.  Prof. Ushio is a member of IEEE, SICE, and ISCIE.
\end{IEEEbiographynophoto}
%\end{IEEEbiography}
%
\end{document}